-> encoding: UTF-8

Robin
=====

-> Tests for functionality "Interpret Robin Program"

The document defines the fundamental semantics of Robin.

Fundamentals
------------

In the following, words in ALL-CAPS indicate variables.

Every Robin program is contained in a `robin` form.  It has the syntax:

    (robin VERSION (MODULE-SPEC ...) EXPRESSION)

The `VERSION` gives the version of the Robin semantics in use.  It has
the syntax:

    (NAT NAT)

...where `NAT` is a natural number (an integer not less than zero.)
More on versions later; the only version of Robin that currently
exists is 0.1 (aka `(0 1)`), so we'll use that.

The list of `MODULE-SPEC`s may be empty.  So, without further ado,
here is one of the simplest Robin programs one can write:

| (robin (0 1) () #t)
= #t

Versioning
----------

The rules for version numbering follow [semantic versioning][].
i.e., If you ask for version 2.1, you may get version 2.2, 2.3,
etc; the assumption is that each of these will implement everything
2.1 does, in a fashion which is backwards-compatible with version 2.1.
You will not get 3.x, because it is assumed 3.x exports a different
interface from 2.x; nor will you get 1.x, for the same reason.  In the
0.x series, nothing is considered backwards-compatible with anything
else; if you ask for 0.2, you will not get 0.1.

Backwards-compatibility does not include functionality which is deemed
to be a bug.  Programs which rely on bugs are themselves buggy, and
when the bug is fixed, they need to be fixed as well.  There is probably
a grey area where it's unclear if something is a bug or a feature, but
my hope is that ample documentation, tests, and literate specifications
where-ever possible will reduce the number of functionalities which
fall into this grey area.

[semantic versioning]: http://semver.org/

An implementation might, obviously, provide or not provide any
particular version of the language.

| (robin (0 781) () #t)
? unsupported language version (0 781)

The Robin semantics brought in by the version number in the `robin`
form include things like datatypes and evaluation rules, and are not
likely to change frequently.  They do not include identifiers.  These
are supplied only by modules, and each module has its own version.

Module Import
-------------

Each `MODULE-SPEC` specifies a module, and a minimum required
version, to import.  It optionally contains a list of qualifiers which
constrain how to import the module.  The identifiers exported by the
module will be available to the `EXPRESSION`.

The module need not be implemented in Robin.

If it is implemented in Robin, when it is imported, the definition of
the module in Robin is evaluated to obtain a binding alist (see
"Conventional Data Types", below, for more details on this data structure.)
The bindings therein are added to the environment in which the
`EXPRESSION` will be evaluated.  They shadow any previous bindings with
the same names.

How the implementation locates any module for loading is *completely*
implementation-dependent.  In Robin, we consider this an implementation-
level detail of which the language is blissfully unaware.  This decouples
the language definition from the details of the operating system, such
as what a "file" is or where they may be loaded from the "file system".

A `MODULE-SPEC` has the syntax:

    (MODULE-NAME VERSION [QUALIFIER...])

It is possible for the list of `MODULE-SPEC`s to be empty, but then
no identifiers will be defined, and you will only be able to state
the most basic of `EXPRESSION`s, such as ones consisting of a single
literal of one of the built-in datatypes that can be expressed directly.

Here is an example of importing a module (but not doing anything
with it.)

| (robin (0 1) ((core (0 1))) #t)
= #t

A particular version of a module might, naturally, not be available.

(TODO: The particular error message produced here may differ.  Falderal
needs a forigiving-error-message option.)

| (robin (0 1) ((small (0 781))) #t)
? module/small_0_781.robin: openFile: does not exist (No such file or directory)

And a particular module might, naturally, not even be available.

| (robin (0 1) ((gzgptzgztxxky (1 0))) #t)
? module/gzgptzgztxxky_1_0.robin: openFile: does not exist (No such file or directory)

And a particular version of a module may rely on a particular version
of the fundamental semantics, so some combinations may not make sense.
For example, if `small` 3.0 relies on Robin 2.0, this will fail
(with a more appropriate error message like "Robin 2.0 required"):

| (robin (1 0) ((small (3 0))) #t)
? unsupported language version (1 0)

By default, identifiers are imported qualified.

| (robin (0 1) ((core (0 1)))
|   (core:number? 3/5))
= #t

| (robin (0 1) ((core (0 1)))
|   (number? 3/5))
? undefined identifier number?

The `*` qualifier imports a module unqualified.

| (robin (0 1) ((core (0 1) *))
|   (number? 3/5))
= #t

| (robin (0 1) ((core (0 1) *))
|   (core:number? 3/5))
? undefined identifier core:number?

Intrinsic Data Types
--------------------

### S-expressions ###

An S-expression is a sort of catch-all data type which includes
all the other data types.  It is inductively defined as follows:

* A symbol is an S-expression.
* A boolean is an S-expression.
* A rational number is an S-expression.
* A macro is an S-expression.
* An opaque value is an S-expression.
* A pair of two S-expressions is an S-expression.
* Nothing else is an S-expression.

S-expressions have a textual representation, but not all types have values
that can be directly expressed in this textual representation.  All
S-expressions have some meaning when interpeted as Robin programs, as
defined by Robin's evaluation rules, but that meaning might be to
raise an exception to indicate an error.

### Symbol ###

A symbol is an atomic value represented by a string of  characters
which may not include whitespace or parentheses or a few other
characters (TODO: decide which ones) and which may not begin with
a `#` (pound sign) or a few other characters (TODO: decide which
ones.)

When in a Robin program proper, a symbol can be bound to a value, and
in this context is it referred to as an _identifier_.  However, if an
attempt is made to evaluate a symbol which is not bound to an identifier,
an exception will be raised.  For a symbol to appear unevaluated in a Robin
program, it must be an argument to a macro.  For that reason, we can't
show an example of a literal symbol without first defining a macro.  For
illustrative purposes, we shall import the macro `literal` from the `small`
module for this purpose, as it is the most straightforward way to create
a literal symbol in a Robin program.

| (robin (0 1) ((small (0 1)))
|   (small:literal hello))
= hello

A Robin program is not expected to be able to generate new symbols
at runtime.

### Booleans ###

There are two values of Boolean type, `#t`, representing truth, and `#f`,
representing falsehood.  By convention, an identifier which ends in `?`
is a macro or function which evaluates to a Boolean.  The `if` macro from
the `core` module expects a Boolean expression as its first argument.

Booleans always evaluate to themselves.

### Rational Numbers ###

A rational number is a pair of integers, called the numerator and the
denominator, considered as a ratio.  No bounds are imposed upon rational
numbers, save that the denominator cannot be zero; further, all rational
numbers in Robin are exact.

The rationale here is that Robin isn't meant for high-performance
numerical computing, which is what floating-point values are meant
for, so it doesn't have them; at the same time, you occasionally
need to compute fractional values, and you don't want to worry
overmuch about whether they will overflow or not.  (Analysis
techniques could be used to prove that, in a performance-critical
section of code, a rational number is always an integer and/or
always within a certain range, and this information could be used
to optimize that section of code.  But we'll worry about that
later.)

For example, 5 is a rational number:

| (robin (0 1) () 5)
= 5

The literal syntax for rational numbers allows one to use `/` to
denote a fraction:

| (robin (0 1) () 4/5)
= 4/5

Rational numbers always evaluate to themselves.

### Macros ###

A macro is an S-expression, in an environment, which describes how to
translate one S-expression to another.

One area where Robin diverges heavily from Lisp and Scheme is that,
whereas Lisp and Scheme support macro capabilities, in Robin, the macro
is a fundamental type.  Other abstractions, such as function values, are
built on top of macros.  Macros are first-class objects that may exist
at runtime and can evaluate to other macros.  Therefore, the word "macro"
has, perhaps, a slightly different meaning in Robin than in Lisp or Scheme.

They can also be compared to the one-argument `lambda` form from PicoLisp;
again, however, unlike PicoLisp's variety of `lambda` forms, Robin's
macros are the only abstraction of this kind fundamentally available, and
other abstractions must be built on top of macros.

Whereas a function evaluates each of its arguments to values, and
binds each of those values to a formal parameter of the function, then
evaluates the body of the function in that new environment, a macro
binds the literal tail of the list of the macro application to the second
formal parameter of the macro, and evaluates the body of the macro.

Each macro has two other formal parameters available to it; the first
formal parameter is bound to the macro itself (to facilitate writing
recursive macros), and the third formal parameter is bound to a binding
alist representing the environment in effect at the point the macro was
evaluated.

There also exist macros which cannot effectively be expressed directly
in Robin -- these are the "built-in" macros.  One such "built-in"
macro is `eval`.  Many macros will make use of `eval`, to evaluate
that literal tail they receive in a (perhaps modified) environment.

Macros are defined with the `macro` macro in the `core` module.
Macros are represented as the S-expression expansion of their
implementation, except in the case of built-in macros.

| (robin (0 1) ((core (0 1)))
|   (core:macro (self args env) args))
= (macro (self args env) args)

A built-in macro is represented thusly.  (TODO: this representation
has problems; see section on pairs below.)

| (robin (0 1) ((core (0 1)))
|   core:pair)
= (builtin pair)

One upshot of built-in macros is that *all* intrinsic Robin functionality,
even things that in Scheme are special forms, can be passed around as
values.

| (robin (0 1) ((core (0 1) *))
|   (pair if (pair head ())))
= ((builtin if) (builtin head))

Macros always evaluate to themselves.

### Pairs ###

TODO: these are only proper lists now.  rewrite this.

A pair is a pair of values of any type (including another pair.)  By
convention, the first of the two values in the pair is referred to as the
"head" of the pair, and the second as the "tail" of the pair.

TODO: write more about this.

| (robin (0 1) ((small (0 1)))
|    (small:literal (7 8)))
= (7 8)

Representations of some types (like built-in macros) look funny because they
don't follow the rules for depicting pairs with a dot and lists without --
effectively, the parens are "fake" on these things.

| (robin (0 1) ((core (0 1) *))
|   (pair #f (pair boolean? ())))
= (#f (builtin boolean?))

Pairs do not evaluate to themselves; rather, they represent a macro
application.  TODO: document this.

Conventional Data Types
-----------------------

This section lists data types that are not intrinsic, but are rather
arrangements of intrinsic types in a way that follows a convention.

### Lists ###

By convention, a list is simply a lopsided tree of pairs.  The first element
(head) of each pair is the value in that position of the list, while the
second element (tail) is either another pair representing the continuation
of the list, or the special value `()`, which is pronounced "null".

TODO: write about how S-expressions are lists unless they contain a dot,
proper vs improper lists, and so forth.

Unlike Scheme, you do not need to quote `()`; it evaluates to itself
rather than indicating an illegal empty application.

| (robin (0 1) () ())
= ()

### Alists ###

An alist, short for "association list", is simply a list of pairs.  The
idea is that each pair associates, somehow, the value in its head with
the value in its tail.

### Binding Alists ###

When the head of each pair in an alist is a symbol, we call it a binding
alist.  The idea is that it is a Robin representation of an evaluation
environment, where the symbols in the heads of the pairs are bound to the
values in the tails of the pairs.  Binding alists can be created from an
environment in effect (such as in the third argument of a macro) and can
be used to change the evaluation environment in effect (such as in the
first argument to `eval`.)

### Strings ###

Strings are just lists of integers, where each integer refers to a
particular Unicode codepoint.  Robin supports a sugared syntax for
specifying literal strings.  The characters of the string are given
between pairs of single quotes.

| (robin (0 1) ((small (0 1) *))
|   (literal ''Hello''))
= (72 101 108 108 111)

A single single quote may appear in string literals of this kind.

| (robin (0 1) ((small (0 1) *))
|   (literal ''He'llo''))
= (72 101 39 108 108 111)

Between the single quotes delimiting the string literal, a *sentinel*
may be given.  The sentinel between the leading single quote pair must
match the sentinel given between the trailing single quote pair.  The
sentinel may consist of any text not containing a single quote.

| (robin (0 1) ((small (0 1) *))
|   (literal 'X'Hello'X'))
= (72 101 108 108 111)

| (robin (0 1) ((small (0 1) *))
|   (literal '...@('Hello'...@('))
= (72 101 108 108 111)

| (robin (0 1) ((small (0 1) *))
|   (literal 'X'Hello'Y'))
? (line 3, column 1):
? unexpected end of input
? expecting "'"

A sentinelized literal like this may embed a pair of single quotes.

| (robin (0 1) ((small (0 1) *))
|   (literal 'X'Hel''lo'X'))
= (72 101 108 39 39 108 111)

By choosing different sentinels, string literals may contain any other
string literal.

| (robin (0 1) ((small (0 1) *))
|   (literal 'X'Hel'Y'bye'Y'lo'X'))
= (72 101 108 39 89 39 98 121 101 39 89 39 108 111)

No interpolation of escape sequences is done in a Robin string literal.
(Functions to convert escape sequences commonly found in other languages
may one day be available in a standard module.)

| (robin (0 1) ((small (0 1) *))
|   (literal ''Hello\nworld''))
= (72 101 108 108 111 92 110 119 111 114 108 100)

All characters which appear in the source text between the delimiters
of the string literal are literally included in the string.

| (robin (0 1) ((small (0 1) *))
|   (literal ''Hello
| world''))
= (72 101 108 108 111 10 119 111 114 108 100)

Adjacent string literals are not automatically concatenated.

| (robin (0 1) ((small (0 1) *))
|   (literal (''Hello'' ''world'')))
= ((72 101 108 108 111) (119 111 114 108 100))

Comments
--------

Any S-expression preceded by a `;` symbol is a comment.  It will still
be parsed, but it will be ignored.

| (robin (0 1) ((core (0 1) *))
|   ;(this program produces a list of two booleans)
|   (pair #f (pair #f ())))
= (#f #f)

Because S-expressions may nest, and because comments may appear
inside S-expressions, comments may nest.

| (robin (0 1) ((core (0 1) *))
|   ;(this program produces
|     ;(what you might call)
|     a list of two booleans)
|   (pair #f (pair #f ())))
= (#f #f)

Comments are still parsed.  A syntax error in a comment is an error.

| (robin (0 1) ((core (0 1) *))
|   ;(this program produces
|     #k
|     a pair of booleans)
|   (pair #f #f))
? (line 3, column 6):
? unexpected "k"
? expecting "t" or "f"

Any number of comments may appear together.

| (robin (0 1) ((core (0 1) *))
|   (pair ;what ;on ;earth #f (pair #f ())))
= (#f #f)

Comments may appear before a closing parenthesis.

| (robin (0 1) ((core (0 1) *))
|   (pair #f (pair #f ()) ;foo))
= (#f #f)

| (robin (0 1) ((core (0 1) *))
|   (pair #f (pair #f ()) ;peace ;(on) ;earth))
= (#f #f)

Comments may appear in an empty list.

| (robin (0 1) ()
|   ( ;hi ;there))
= ()

Comments need not be preceded by spaces.

| (robin (0 1) ()
|   (;north;by;north;west))
= ()

To put truly arbitrary text in a comment, the string sugar syntax may be
used.

| (robin (0 1) ((core (0 1) *))
|   ;''This program, it produces a list of two booleans. #k ?''
|   (pair #f (pair #f ())))
= (#f #f)

Standard Modules
----------------

### `core` ###

Robin's `core` module exports the fundamental functionality that is used
to evaluate programs, and that cannot be expressed as macros written
in Robin.

`core` is not optional -- every Robin implementation must provide a
`core` module, or it's not Robin.

The `core` module is documented in
[module/Core.falderal](module/Core.falderal).

### `small` ###

Robin's `small` module exports everything `core` does, and a few
macros (which could be written in Robin, but could also be implemented
natively for efficiency) to make writing programs somewhat easier --
basically to bring the language up to parity, in expressive power, with
Pixley.

`small` is technically an optional module, but it's really handy,
and could be written in pure Robin, so it's likely to be available.

The `small` module is documented in
[module/Small.falderal](module/Small.falderal).

### `exception` ###

Robin's `exception` module exports macros for catching exceptions.

This module is optional.  A Robin form that imports this module is asserting
that it requires an implementation in which exceptions can be caught.

Note that exceptions can still be raised in an implementation where they
cannot be caught; they simply cause an immediate termination of the Robin
program instead.

The `exception` module is documented in
[module/Exception.falderal](module/Exception.falderal).

### `concurrency` ###

Robin's `concurrency` module exports macros for working with concurrently-
executing processes which communicate with each other via message-
passing.

This module is optional.  A Robin form that imports this module is asserting
that it requires an implementation which supports concurrency.

The `concurrency` module is documented in
[module/Concurrency.falderal](module/Concurrency.falderal).

### `list` ###

Robin's `list` module exports macros and functions for working with
data of conventional list type.

All macros in this module can be expressed in Robin, but of course
could also be implemented natively for efficiency.

`list` is technically an optional module, but it's really handy,
and could be written in pure Robin, so it's likely to be available.

The `list` module is documented in
[module/List.falderal](module/List.falderal).

### `env` ###

Robin's `env` module exports macros and functions for examining and
manipulating evaluation environments and, to the extent they are
represented as binding alists, binding alists.

All macros in this module can be expressed in Robin, but of course
could also be implemented natively for efficiency.

`env` is technically an optional module, but it's really handy,
and could be written in pure Robin, so it's likely to be available.

The `env` module is documented in
[module/Environment.falderal](module/Environment.falderal).

### `boolean` ###

Robin's `boolean` module exports macros and functions for working
with Boolean values, including the traditional Boolean operators.

All macros in this module can be expressed in Robin, but of course
could also be implemented natively for efficiency.

`boolean` is technically an optional module, but it's really handy,
and could be written in pure Robin, so it's likely to be available.

The `boolean` module is documented in
[module/Boolean.falderal](module/Boolean.falderal).

### `arith` ###

Robin's `arith` module exports macros and functions for performing
basic arithmetic and numeric comparison operations.

All macros in this module can be expressed in Robin, but of course
could also be implemented natively for efficiency.

`arith` is technically an optional module, but it's really handy,
and could be written in pure Robin, so it's likely to be available.

The `arith` module is documented in
[module/Arithmetic.falderal](module/Arithmetic.falderal).

### `crude-io` ###

Robin's `crude-io` module exports a rudimentary, process-based
interface to the operating system's idea of "standard input" and
"standard output".  Textual S-expressions may be read and written,
one per line.

`crude-io` is an optional module.  It cannot be written directly
in Robin.

The `crude-io` module is documented in
[module/CrudeIO.falderal](module/CrudeIO.falderal).

### `random` ###

Robin's `random` module exports a process-based interface to a pseudo-
random number generator.

`random` is an optional module.  It can be written in Robin, save for the
fact that it is not deterministic (seeding is a problem.)

The `random` module is documented in
[module/Random.falderal](module/Random.falderal).
