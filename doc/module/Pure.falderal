-> encoding: UTF-8

Module `pure`
=============

-> Functionality "Interpret Robin Program" is implemented by
-> shell command "bin/robin %(test-file)"

-> Tests for functionality "Interpret Robin Program"

The `pure` module is an EXPERIMENTAL module for EXPERIMENTING with
static analysis, namely to determine if functions cannot possibly have
side-effects (are "pure") or not.

A macro is considered pure if, for every set of possible particular actual
arguments, it always evaluates to the same particular result value.

As described in the Style document, the only "side-effects" in Robin are
spawning a process, sending a message to a process, and receiving a message
from a process, and these can be distinguished at a lower level than simply
"might this have side-effects or not".  But for now, for simplicitly, I'm
going to glom them all together under this banner.

### Re-exports ###

`pure` re-exports everything in `core`, and a few things from `small`,
but marked with `pure` in the metadata (except `eval` where this is far
from a guarantee.)

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) head))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) tail))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) pair))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) if))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) macro))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) fun))
= #t

### `pure?` ###

The first argument is an environment.  The second argument is a list
of symbols which are the formal parameters of the function.  The third
argument is a literal term which is the body of the function.

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) () (literal 4)))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) () (literal (subtract 4 5))))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) (literal (a b)) (literal (subtract a b))))
= #t

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure? (env) (literal (a b)) (literal (send! (myself) 3))))
= #f

A function which evaluates to a pure built-in macro is pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) (literal (foo)) (literal head)))
= #t

A function which evaluates to a pure macro is pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) (literal (foo)) (literal (macro (self args env) foo))))
= #t

A function which evaluates to an impure macro is still pure, as long as
the impure macro is determined entirely by the parameters to the pure
function.  But, our purity prover doesn't understand this yet.

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure? (env) (literal (pid)) (literal (macro (self args env) (send! pid 3)))))
= #t

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure? (env) (literal (pid)) (literal
|     (pair (macro (self args env) pid)
|           (macro (self args env) (send! pid 3))))))
= #t

An otherwise pure function which calls a pure function that it defines
within itself is pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) (literal (x)) (literal
|     (bind y (macro (self args env) x)
|       (y 123)))))
= #t

An otherwise pure function which calls an impure function that it defines
within itself is not pure.

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure? (env) (literal (pid)) (literal
|     (bind y (macro (self args env) (send! pid 3))
|       (y)))))
= #f

An otherwise pure function which simply binds something that it does not use
is still pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) (literal (x)) (literal
|     (bind y 23 x))))
= #t

A function which applies one of its arguments is not pure, because its
argument might not be pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure? (env) (literal (x)) (literal
|     (x 123))))
= #f

### `pure-fun` ###

(This was copied from the Static Analysis doc and needs rewriting.)

We can define a macro called, say, `pure-fun`.  It accepts the same kinds
of arguments as `fun`:

    (bind perimeter (pure-fun (w h) (* 2 (+ w h)))
        ...)

`pure-fun` however, examines its second argument in detail before
evaluating to a function value which implements this function.  It looks up
`*` in its environment, sees that there is metadata on the value referred
to `*` that indicates that it is pure, and continues.  It descends into the
term, and sees that `2`, being a literal value, is pure; it sees that `+`
is also pure; and it sees that `w` and `h` are arguments to the function.
(If these aren't pure, that's not a problem with this function per se.)
Having thus proven the expression to be pure, it evaluates the function
value in the exact same way that `fun` would, then adds metadata to that
value that marks it as `pure`.

Then `bind` binds the identifier `perimeter` to this value, which has
been marked as `pure`; so when we look up `perimeter` in this environment,
we know it refers to a pure function.  We can use this information in
subsequent checks, like:

    (bind perimeter (pure-fun (w h) (* 2 (+ w h)))
      (bind psquare (pure-fun (w) (perimeter w w))
        ...))

This is all well and good for functions, but for other macros, we may
need to do more work.  Specifically, a macro like `fun` itself, which
defines a custom syntax, might need to describe what their syntax is
like, in their metadata, so that the purity analyzer can recognize them
and process them correctly.

Probably the most sensible place to start with all this is a macro which
defines a function if and only if it can prove that the function has no
side-effects.  (Otherwise, it presumably raises an exception.)
