-> encoding: UTF-8

Module `pure`
=============

-> Functionality "Interpret Robin Program" is implemented by
-> shell command "bin/robin %(test-file)"

-> Tests for functionality "Interpret Robin Program"

The `pure` module is an EXPERIMENTAL module for EXPERIMENTING with
static analysis, namely to determine if functions cannot possibly have
side-effects (are "pure") or not.

A macro is considered pure if, for every set of possible particular actual
arguments, it always evaluates to the same particular result value.

As described in the Style document, the only "side-effects" in Robin are
spawning a process, sending a message to a process, and receiving a message
from a process, and these can be distinguished at a lower level than simply
"might this have side-effects or not".  But for now, for simplicitly, I'm
going to glom them all together under this banner.

### Re-exports ###

`pure` re-exports everything in `core`, and a few things from `small`,
but marked with `pure` in the metadata (except `eval` where this is far
from a guarantee.)

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) head))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) tail))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) pair))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) if))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) macro))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (has? (literal pure) fun))
= #t

### Purity Analysis ###

Purity analysis is implemented with two main predicates.  The first,
`pure-expr?`, checks if an expression is pure -- that no side-effects
occur during its evaluation.  The second, `pure-macro-defn?`, checks if an
expression evaluates to a macro which is pure.

These two functions call each other in mutual recursion.  An expression
which evaluates to an impure macro can still be pure, when no side-effects
occur during the evaluation that results in the macro.  However, if an
expression applies a macro that it defines, we need to check whether the
macro has any side effects, to determine if the expression is pure.

Typically, user code would not call these predicates directly; instead
it would use `pure-fun` to define functions, which would check them for
purity before making them available to the rest of the program.

### `pure-expr?` ###

The first argument is an environment.  The second argument is a list
of symbols which are the formal parameters of the function.  The third
argument is a literal term which is the body of the function.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) () (literal 4)))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) () (literal (subtract 4 5))))
= #t

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (a b)) (literal (subtract a b))))
= #t

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure-expr? (env) (literal (a b)) (literal (send! (myself) 3))))
= #f

An otherwise pure function which simply binds something that it does not use
is still pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|     (bind y 23 x))))
= #t

An otherwise pure function which binds some pure values to names is still
pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|     (bind y (subtract x 23) (bind r 5 (subtract y r))))))
= #t

A function which evaluates to a pure built-in macro is pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (foo)) (literal head)))
= #t

A function which evaluates to a pure macro is pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (foo)) (literal (macro (self args env) foo))))
= #t

A function which evaluates to an impure macro is still pure, as long as
the impure macro is determined entirely by the parameters to the pure
function.

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure-expr? (env) (literal (pid)) (literal
|      (macro (self args env) (send! pid 3)))))
= #t

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure-expr? (env) (literal (pid)) (literal
|     (pair (macro (self args env) pid)
|           (macro (self args env) (send! pid 3))))))
= #t

An otherwise pure function which calls a pure function that it defines
within itself is pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|       ((fun (y) y) 123))))
= #t

Even if it is a macro.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|       ((macro (self args env) args) 123))))
= #t

Even if it uses closed-over identifiers.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|       ((macro (self args env) x) 123))))
= #t

Even if it was bound to a name first.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|     (bind y (macro (self args env) x)
|       (y 123)))))
= #t

An otherwise pure function which calls an impure function that it defines
within itself is not pure.

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure-expr? (env) (literal (pid)) (literal
|     ((macro (self args env) (send! pid 3))))))
= #f

Even if it was bound to a name first.

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure-expr? (env) (literal (pid)) (literal
|     (bind y (macro (self args env) (send! pid 3))
|       (y)))))
= #f

If we bind a name to an impure expression, the function is not pure, even
if it doesn't use the name.

| (robin (0 . 1) (pure (0 . 1) concurrency (0 . 1))
|   (pure-expr? (env) (literal (pid)) (literal
|      (bind n (send! pid 3) pid))))
= #f

A function which applies one of its arguments is not pure, because its
argument might not be pure.

| (robin (0 . 1) (pure (0 . 1))
|   (pure-expr? (env) (literal (x)) (literal
|     (x 123))))
= #f

### `pure-macro-defn?` ###

TBW

### `pure-fun` ###

(This was copied from the Static Analysis doc and needs rewriting.)

We can define a macro called, say, `pure-fun`.  It accepts the same kinds
of arguments as `fun`:

    (bind perimeter (pure-fun (w h) (* 2 (+ w h)))
        ...)

`pure-fun` however, examines its second argument in detail before
evaluating to a function value which implements this function.  It looks up
`*` in its environment, sees that there is metadata on the value referred
to `*` that indicates that it is pure, and continues.  It descends into the
term, and sees that `2`, being a literal value, is pure; it sees that `+`
is also pure; and it sees that `w` and `h` are arguments to the function.
(If these aren't pure, that's not a problem with this function per se.)
Having thus proven the expression to be pure, it evaluates the function
value in the exact same way that `fun` would, then adds metadata to that
value that marks it as `pure`.

Then `bind` binds the identifier `perimeter` to this value, which has
been marked as `pure`; so when we look up `perimeter` in this environment,
we know it refers to a pure function.  We can use this information in
subsequent checks, like:

    (bind perimeter (pure-fun (w h) (* 2 (+ w h)))
      (bind psquare (pure-fun (w) (perimeter w w))
        ...))

This is all well and good for functions, but for other macros, we may
need to do more work.  Specifically, a macro like `fun` itself, which
defines a custom syntax, might need to describe what their syntax is
like, in their metadata, so that the purity analyzer can recognize them
and process them correctly.

Probably the most sensible place to start with all this is a macro which
defines a function if and only if it can prove that the function has no
side-effects.  (Otherwise, it presumably raises an exception.)
