-> encoding: UTF-8

Module `crude-io`
=================

The `crude-io` module exports two processes which may be used to achieve
a crude form of input and output with the outside world.  This module is
very much a "throw one away" approach to I/O, is not in the least intended
to solve all problems related to I/O, relies heavily on existing operating
system concepts and limitations about I/O, and will be superceded by a
more refined approach to I/O in some other module at some point.

### `crude-output` ###

The `crude-output` identifier is bound to a process which accepts messages
sent to it, and outputs the content of those messages to the operating
system's "standard output".

Each message should be in the `call!` format, which is a list of three items:
the pid of the sender, the tag (which should be the symbol `write`), and
the payload (which is the value which we intend to output.)

The payload will be formatted as a textual S-expression, and this text will
be written, as a line, to the standard output.  After the text has been
written, a confirmation message (in the standard `call!` response format)
consisting of the symbol `ok` will be sent back to the process that sent
the message.

To ensure that the text is written, the sending process should wait for
this confirmation message.  The simplest way to do this is to use the
`call!` macro.  If the program terminates before this confirmation message
is received, the text might not be written to the standard output.

-> Tests for shell command "bin/robin %(test-file)"

Sending a message to `crude-output` causes the contents of the message to
be written to the standard output, and an `ok` message sent back to the
sending process as a confirmation.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (call! crude-output write (literal hello-world) reply reply))
= hello-world
= ok

-> Tests for shell command "bin/robin -n %(test-file)"

The sending process need not do anything with the response.  The
implementation need not write the result of the main process to the
standard output.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (call! crude-output write (literal hello-world) reply 0))
= hello-world

Multiple messages may be sent to `crude-output`; the content of each
message will be formatted as a textual S-expression, and written out on
its own line.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (call! crude-output write (literal hello) x
|     (call! crude-output write (literal (world 1 2 3)) y
|       0)))
= hello
= (world 1 2 3)

### `crude-input` ###

The `crude-input` identifier is bound to a process which accepts
subscription messages sent to it.  A subscription message is in `call!`
format, with the tag `subscribe`; the payload is ignored.  The process
which sent the subscription message is the process that will be
subscribed to receive data from lines read on the program's "standard
input".

After receiving a subscription message, that pid is added to `crude-input`'s
list of subscribers.  After a line of text has been entered, that line is
parsed as a textual S-expression, and the value of that expression is sent
to all subscribers.

`crude-input` will not send any message until an entire line has been
entered and parsed correctly.

-> Tests for shell command "echo 'hello' | bin/robin %(test-file)"

`crude-input` can be subscribed to, and the subscriber will receive
messages when input occurs.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (call! crude-input subscribe () x
|     (recv! entered
|       (pair (literal i-got) entered))))
= (i-got . hello)

-> Tests for shell command "echo '(1 2 3)' | bin/robin %(test-file)"

Arbitrary S-expressions may occur on each line; they are parsed.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (call! crude-input subscribe () x
|     (recv! entered
|       (pair (literal i-got) entered))))
= (i-got 1 2 3)

-> Tests for shell command "/bin/echo -e '1\n2\n3\n' | bin/robin -n %(test-file)"

Multiple lines of text may be input, and multiple messages will be sent.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (bind input-loop
|         (fun (self)
|           (recv! entered
|             (if (equal? entered (literal eof))
|               #f
|               (call! crude-output write (pair #t entered) foo
|                 (self self)))))
|     (call! crude-input subscribe () x
|       (input-loop input-loop))))
= (#t . 1)
= (#t . 2)
= (#t . 3)

-> Tests for shell command "/bin/echo -e '1\n#r\n3\n' | bin/robin -n %(test-file)"

If an S-expression on a given line cannot be parsed, no message will be
sent.

| (robin (0 . 1) (small (0 . 1) concurrency (0 . 1) crude-io (0 . 1))
|   (bind input-loop
|         (fun (self)
|           (recv! entered
|             (if (equal? entered (literal eof))
|               #f
|               (call! crude-output write (pair #t entered) foo
|                 (self self)))))
|     (call! crude-input subscribe () x
|       (input-loop input-loop))))
= (#t . 1)
= (#t . 3)
