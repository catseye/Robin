-> encoding: UTF-8

Module `list`
=============

-> Functionality "Interpret Robin Program" is implemented by
-> shell command "bin/robin %(test-file)"

-> Tests for functionality "Interpret Robin Program"

The `lists` module exports macros and functions for working with data of
conventional list type.

### `list` ###

`list` is a macro which evaluates each of its arguments, and evaluates to a
(proper) list containing each of the results, in the same order.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list 1 2 3 4 5))
= (1 2 3 4 5)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list (pair 2 3) (pair 6 7)))
= ((2 . 3) (6 . 7))

`list` need not have any arguments at all; the result is the empty list.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list))
= ()

### `empty?` ###

`empty?` evaluates its single argument, and evaluates to `#t` if that value
is the empty list, `#f` otherwise.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (empty? (literal symbol)))
= #f

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (empty? ()))
= #t

### `list?` ###

`list?` evaluates its single argument, and evaluates to `#t` if that value
is a proper list, `#f` otherwise.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list? (literal symbol)))
= #f

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list? ()))
= #t

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list? (literal (a b c))))
= #t

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (list? (pair 1 2)))
= #f

### `map` ###

`map` evaluates its first argument to obtain a macro, and its second argument
to obtain a list.  It then evaluates to a list which is obtained by applying
the macro to each element of the given list.  The macro is generally assumed
to be a one-argument function.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (map (fun (x) (list x)) (literal (three dog night))))
= ((three) (dog) (night))

### `fold` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (fold (fun (x a) (pair a x)) () (literal (three dog night))))
= (((() . three) . dog) . night)

### `reverse` ###

`reverse` evaluates its argument to a list, then evaluates to a list which
is the same as the given list in every respect except that the order of
the elements is reversed.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (reverse (literal (1 2 3 4 5))))
= (5 4 3 2 1)

### `filter` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (filter (fun (x) (symbol? x)) (literal (1 two #f 3 () four 5 six))))
= (two four six)

### `find` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (find (fun (x) (symbol? x)) ()))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (find (fun (x) (symbol? x)) (list 1 2 3)))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (find (fun (x) #t) (list 1 2 3)))
= (1)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (find (fun (x) (symbol? x)) (literal (1 two #f 3 () four 5 six))))
= (two)

### `elem` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (elem (literal p) (literal (a p e))))
= #t

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (elem (literal p) (literal (a r k))))
= #f

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (elem 7 ()))
= #f

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (elem 7 (list 5 (list 6 7) 8)))
= #f

### `append` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (append (list 1 2 3) (list 4 5 6)))
= (1 2 3 4 5 6)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (append () ()))
= ()

### `length` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (length ()))
= 0

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (length (list 1 2 #t #f 3)))
= 5

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (length (literal whatnot)))
? robin: uncaught exception: (expected-pair . whatnot)

### `index` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (index 0 (literal (the girl from ipanema))))
= the

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (index 2 (literal (the girl from ipanema))))
= from

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (bind last (fun (li) (index (subtract (length li) 1) li))
|     (last (literal (the girl from ipanema)))))
= ipanema

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (index 7 (literal (the girl from ipanema))))
? robin: uncaught exception: (expected-pair)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (index (literal goofy) (list 1 2 3 4 5)))
? robin: uncaught exception: (expected-number . goofy)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (index 8 (literal whatnot)))
? robin: uncaught exception: (expected-pair . whatnot)

### `take-while` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (take-while (fun (x) (symbol? x)) (literal (one two 3 4 five 6 seven))))
= (one two)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (take-while (fun (x) (symbol? x)) (literal (1 2 3 4 five six))))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (take-while (fun (x) (number? x)) (literal (1 2 3 4 5 6))))
= (1 2 3 4 5 6)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (take-while (fun (x) (symbol? x)) ()))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (take-while (fun (x) (symbol? x)) #f))
? robin: uncaught exception: (expected-pair . #f)

### `drop-while` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (drop-while (fun (x) (symbol? x)) (literal (one two 3 4 five 6 seven))))
= (3 4 five 6 seven)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (drop-while (fun (x) (symbol? x)) (literal (1 2 3 4 5 6))))
= (1 2 3 4 5 6)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (drop-while (fun (x) (number? x)) (literal (1 2 3 4 5 6))))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (drop-while (fun (x) (symbol? x)) ()))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (drop-while (fun (x) (symbol? x)) #f))
? robin: uncaught exception: (expected-pair . #f)

### `first` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (first 0 (list 1 2 3 4 5)))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (first 3 (list 1 2 3 4 5)))
= (1 2 3)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (first 6 (list 1 2 3 4 5)))
? robin: uncaught exception: (expected-pair)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (first 6 (list 1 2 3 4 5 . 6)))
? robin: uncaught exception: (expected-pair . 6)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (first 1 (literal foo)))
? robin: uncaught exception: (expected-pair . foo)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (first 0 (literal foo)))
= ()

### `rest` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 0 (list 1 2 3 4 5)))
= (1 2 3 4 5)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 3 (list 1 2 3 4 5)))
= (4 5)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 5 (list 1 2 3 4 5)))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 6 (list 1 2 3 4 5)))
? robin: uncaught exception: (expected-pair)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 6 (list 1 2 3 4 5 . 6)))
? robin: uncaught exception: (expected-pair . 6)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 1 (literal foo)))
? robin: uncaught exception: (expected-pair . foo)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (rest 0 (literal foo)))
= foo

### `last` ###

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (last 0 (list 1 2 3 4 5)))
= ()

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (head (last 1 (list 1 2 3 4 5))))
= 5

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (last 3 (list 1 2 3 4 5)))
= (3 4 5)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (last 6 (list 1 2 3 4 5)))
? robin: uncaught exception: (expected-pair)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (last 6 (list 1 2 3 4 5 . 6)))
? robin: uncaught exception: (expected-pair . 6)

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (last 1 (literal foo)))
? robin: uncaught exception: (expected-pair . foo)

Unlike `first`, `last` does care if it's not a list, even when the count
is zero.

| (robin (0 . 1) (small (0 . 1) list (0 . 1))
|   (last 0 (literal foo)))
? robin: uncaught exception: (expected-pair . foo)
