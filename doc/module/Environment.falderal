-> encoding: UTF-8

Module `env`
============

-> Functionality "Interpret Robin Program" is implemented by
-> shell command "bin/robin %(test-file)"

-> Tests for functionality "Interpret Robin Program"

### `env?` ###

`env?` evaluates its single argument, and evaluates to `#t` if
and only if it is a well-formed binding alist.

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (env? (literal ((a . 1) (b . 2) (c . 3)))))
= #t

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (env? (literal ((a . 1) (999 . 2) (c . 3)))))
= #f

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (env? (literal ((a . 1) (b . 2) . c))))
= #f

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (env? 7))
= #f

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (env? (env)))
= #t

### `unbind` ###

`unbind` removes the given symbol from the environment and evaluates its
second argument in that reduced environment.

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (unbind if (if #t (literal x) (literal y))))
? robin: uncaught exception: (unbound-identifier . if)

`unbind` removes all trace of binding from the given symbol; if it has
several definitions that are shadowed, none of them will be in effect.

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (let ((x 7))
|     (let ((x 8))
|       (unbind x
|         x))))
? robin: uncaught exception: (unbound-identifier . x)

### `sandbox` ###

`sandbox` takes a list of identifiers as its first argument, and evaluates
its second argument in an environment where all bindings *except* those
for the listed identifiers have been unbound.

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (sandbox (pair tail)
|     (tail (pair 8 9))))
= 9

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (sandbox (pair tail)
|     (head (pair 8 9))))
? robin: uncaught exception: (unbound-identifier . head)

### `export` ###

`export` treats its arguments as a list of identifiers, and returns an
environment where only those identifiers are bound to values.

The original idea for `sandbox` was that it could be used in the body of
a module to restrict the visible identifiers to those the module wished
to export, which could then actually be exported with `env`.  However,
this still required `env` to be a visible identifier (and thus exported.)
`export` simply evaluates to a binding alist which can be returned
directly.

Note: the order of the bindings in the binding alist isn't guaranteed;
these tests should be rewritten to search the resulting alist.

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (let ((a 1) (b 2))
|     (export a b)))
= ((b . 2) (a . 1))

| (robin (0 . 1) (small (0 . 1) env (0 . 1))
|   (export pair tail))
= ((tail . (builtin tail)) (pair . (builtin pair)))
