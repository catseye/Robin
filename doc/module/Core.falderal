-> encoding: UTF-8

Module `core`
=============

-> Functionality "Interpret Robin Program" is implemented by
-> shell command "bin/robin %(test-file)"

-> Tests for functionality "Interpret Robin Program"

Robin's `core` module exports the set of intrinsic macros on top of which
all other Robin macros and programs are built.

### `pair` ###

`pair` evaluates both of its arguments, then evaluates to a pair which
contains both of those values, in the same order.

| (robin (0 . 1) (core (0 . 1))
|   (pair #t #f))
= (#t . #f)

| (robin (0 . 1) (core (0 . 1))
|   (pair #t (pair #f ())))
= (#t #f)

Arguments to `pair` can be any type, but fewer than or more than
two arguments will raise an exception.

| (robin (0 . 1) (core (0 . 1))
|   (pair #t))
? robin: uncaught exception: (illegal-arguments #t)

| (robin (0 . 1) (core (0 . 1))
|   (pair #f #t #f))
? robin: uncaught exception: (illegal-arguments #f #t #f)

### `head` ###

`head` evaluates its argument to a pair, and evaluates to the first element
of that pair.

| (robin (0 . 1) (core (0 . 1))
|   (head (pair #t #f)))
= #t

`head` expects its argument to be a pair.

| (robin (0 . 1) (core (0 . 1))
|   (head #f))
? robin: uncaught exception: (expected-pair . #f)

`head` expects exactly one argument.

| (robin (0 . 1) (core (0 . 1))
|   (head (pair #t #f) (pair #f #t)))
? robin: uncaught exception: (illegal-arguments (pair #t #f) (pair #f #t))

| (robin (0 . 1) (core (0 . 1))
|   (head))
? robin: uncaught exception: (illegal-arguments)

### `tail` ###

Likewise, the horribly-named `tail` also evaluates its argument to a
pair, and evaluates to the second element of that pair.

| (robin (0 . 1) (core (0 . 1))
|   (tail (pair #t #f)))
= #f

`tail` expects its argument to be a pair.

| (robin (0 . 1) (core (0 . 1))
|   (tail #f))
? robin: uncaught exception: (expected-pair . #f)

`tail` expects exactly one argument.

| (robin (0 . 1) (core (0 . 1))
|   (tail (pair #t #f) (pair #f #t)))
? robin: uncaught exception: (illegal-arguments (pair #t #f) (pair #f #t))

| (robin (0 . 1) (core (0 . 1))
|   (tail))
? robin: uncaught exception: (illegal-arguments)

### `if` ###

`if` evaluates its first argument to a boolean value.  If that value is
`#t`, it evaluates, and evaluates to, its second argument; or if that value
is `#f` it evaluates, and evaluates to, its third argument.  In all cases,
at most two arguments are evaluated.

| (robin (0 . 1) (core (0 . 1))
|   (if #t 7 9))
= 7

| (robin (0 . 1) (core (0 . 1))
|   (if #f 7 9))
= 9

The second and third arguments can be arbitrary expressions, but `if`
expects its first argument to be a boolean.

| (robin (0 . 1) (core (0 . 1))
|   (if 5 7 9))
? robin: uncaught exception: (expected-boolean . 5)

`if` expects exactly three arguments.

| (robin (0 . 1) (core (0 . 1))
|   (if #t 7))
? robin: uncaught exception: (illegal-arguments #t 7)

| (robin (0 . 1) (core (0 . 1))
|   (if #t 7 8 9))
? robin: uncaught exception: (illegal-arguments #t 7 8 9)

### `equal?` ###

`equal?` evaluates both of its arguments to arbitrary S-expressions
and compares them for deep equality.

`equal?` works on symbols.

| (robin (0 . 1) (core (0 . 1))
|   (equal?
|     ((macro (s a e) (head a)) this-symbol)
|     ((macro (s a e) (head a)) this-symbol)))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (equal?
|     ((macro (s a e) (head a)) this-symbol)
|     ((macro (s a e) (head a)) that-symbol)))
= #f

`equal?` works on lists.

| (robin (0 . 1) (core (0 . 1))
|   (equal? (pair 1 (pair 2 (pair 3 ())))
|           (pair 1 (pair 2 (pair 3 ())))))
= #t

Two values of different types are never equal.

| (robin (0 . 1) (core (0 . 1))
|   (equal? #t
|           (pair ((macro (self args env) (head args)) a) ())))
= #f

| (robin (0 . 1) (core (0 . 1))
|   (equal? #f
|           ()))
= #f

Arguments to `equal?` can be any type, but fewer than or more than
two arguments will raise an exception.

| (robin (0 . 1) (core (0 . 1))
|   (equal? 7))
? robin: uncaught exception: (illegal-arguments 7)

| (robin (0 . 1) (core (0 . 1))
|   (equal? 7 8 9))
? robin: uncaught exception: (illegal-arguments 7 8 9)

### `pair?` ###

`pair?` evaluates its argument, then evaluates to `#t` if it is a pair,
`#f` otherwise.

| (robin (0 . 1) (core (0 . 1))
|   (pair? ((macro (self args env) (head args)) (a . b))))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (pair? ((macro (self args env) (head args)) (a b c d e f))))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (pair? (pair 4 5)))
= #t

Symbols are not pairs.

| (robin (0 . 1) (core (0 . 1))
|   (pair? ((macro (self args env) (head args)) b)))
= #f

The argument to `pair?` may (naturally) be any type, but there must be
exactly one argument.

| (robin (0 . 1) (core (0 . 1))
|   (pair? (pair 4 5) (pair 6 7)))
? robin: uncaught exception: (illegal-arguments (pair 4 5) (pair 6 7))

### `macro?` ###

`macro?` evaluates its argument, then evaluates to `#t` if it is a macro
(either built-in or user-defined), or `#f` if it is not.

| (robin (0 . 1) (core (0 . 1))
|   (macro? (macro (self args env) args)))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (macro? macro))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (macro? ((macro (self args env) (head args)) macro)))
= #f

| (robin (0 . 1) (core (0 . 1))
|   (macro? 4/5))
= #f

The argument to `macro?` may (naturally) be any type, but there must be
exactly one argument.

| (robin (0 . 1) (core (0 . 1))
|   (macro? macro macro))
? robin: uncaught exception: (illegal-arguments macro macro)

### `symbol?` ###

`symbol?` evaluates its argument, then evaluates to `#t` if it is a symbol,
`#f` otherwise.

| (robin (0 . 1) (core (0 . 1))
|   (symbol? ((macro (s a e) (head a)) this-symbol)))
= #t

Pairs are not symbols.

| (robin (0 . 1) (core (0 . 1))
|   (symbol? (pair 1 2)))
= #f

The argument to `symbol?` may (naturally) be any type, but there must be
exactly one argument.

| (robin (0 . 1) (core (0 . 1))
|   (symbol? 77 88))
? robin: uncaught exception: (illegal-arguments 77 88)

### `boolean?` ###

`boolean?` evaluates its argument, then evaluates to `#t` if it is a
boolean value, `#f` otherwise.

| (robin (0 . 1) (core (0 . 1))
|   (boolean? #t))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (boolean? #f))
= #t

| (robin (0 . 1) (core (0 . 1))
|   (boolean? ()))
= #f

The argument to `symbol?` may (naturally) be any type, but there must be
exactly one argument.

| (robin (0 . 1) (core (0 . 1))
|   (boolean? #t #f))
? robin: uncaught exception: (illegal-arguments #t #f)

### `eval` ###

`eval` evaluates its first argument to obtain an environment, then
evaluates its second argument to obtain an S-expression; it then
evaluates that S-expression in the given environment.

TODO: these tests use things from the `small` module; for the
sake of purity, that dependency should be removed (but the tests
will look awful.)

| (robin (0 . 1) (small (0 . 1))
|   (eval (env) (literal (pair (literal a) (literal b)))))
= (a . b)

| (robin (0 . 1) (small (0 . 1))
|   (eval () (literal (pair (literal a) (literal b)))))
? robin: uncaught exception: (unbound-identifier . pair)

| (robin (0 . 1) (small (0 . 1))
|   (bind bindings (pair
|                    (pair (literal same) equal?)
|                    (pair (pair (literal x) #f) (literal ())))
|     (eval bindings (literal (same x x)))))
= #t

If two bindings for the same identifier are supplied in the environment
alist passed to `eval`, the one closer to the front of the alist takes
precedence.

| (robin (0 . 1) (small (0 . 1))
|   (bind bindings (pair
|                    (pair (literal foo) (literal yes))
|                    (pair (pair (literal foo) (literal no))
|                       (literal ())))
|     (eval bindings (literal foo))))
= yes

`eval` will happily use whatever type of value you like as the
environment, however, subsequent evaluation will fail when it
tries to look up things in that environment.

| (robin (0 . 1) (small (0 . 1))
|   (eval 103 (literal (pair (literal a) (literal b)))))
? robin: uncaught exception: (expected-pair . 103)

Evaluation expects the contents of the list which makes up the
environment to be pairs.

| (robin (0 . 1) (small (0 . 1))
|   (eval (pair #f ()) (literal (pair (literal a) (literal b)))))
? robin: uncaught exception: (expected-pair . #f)

Evaluation expects the head of each pair in the list which makes up the
environment to be a symbol.

| (robin (0 . 1) (small (0 . 1))
|   (eval (pair (pair 7 #f) ()) (literal (pair (literal a) (literal b)))))
? robin: uncaught exception: (expected-symbol . 7)

`eval` expects exactly two arguments.

| (robin (0 . 1) (core (0 . 1))
|   (eval))
? robin: uncaught exception: (illegal-arguments)

| (robin (0 . 1) (core (0 . 1))
|   (eval 4 5 6))
? robin: uncaught exception: (illegal-arguments 4 5 6)

### `macro` ###

`macro` takes its first argument to be a list of three formal
parameters, and its second argument to be an arbitrary expression,
and uses these two arguments to build, and evaluate to, a macro
value.

When this macro value is evaluated, the first formal argument will
be bound to the macro itself, the second will be bound to the
literal, unevaluated list of arguments passed to the macro, and the
third will be bound to an alist representing the environment in
effect at the point the macro value is evaluated.

These formals are conventionally called `self`, `args`, and `env`,
but different names can be chosen in the `macro` definition, for
instance to avoid shadowing.

`literal`, in fact, can be defined as a macro, and it is one of the
simplest possible macros that can be written:

| (robin (0 . 1) (core (0 . 1))
|   ((macro (self args env) (head args)) (why hello there)))
= (why hello there)

`self` is there to let you write recursive macros.  The following
example demonstrates this; it evaluates `(pair b d)` in an environment
where all the identifiers you list after `qqq` have been bound to 0.

TODO: these tests use things from the `small` module; for the
sake of purity, that dependency should be removed (but the tests
will look awful.)

| (robin (0 . 1) (small (0 . 1))
|   (bind qqq
|     (macro (self args env)
|       (if (equal? args ())
|         (eval env (literal (pair b d)))
|         (eval (pair (pair (head args) 0) env)
|           (pair self (tail args)))))
|     (bind b 1 (bind d 4 (qqq b c d)))))
= (0 . 0)

| (robin (0 . 1) (small (0 . 1))
|   (bind qqq
|     (macro (self args env)
|       (if (equal? args ())
|         (eval env (literal (pair b d)))
|         (eval (pair (pair (head args) 0) env)
|           (pair self (tail args)))))
|     (bind b 1 (bind d 4 (qqq x y z)))))
= (1 . 4)

Your recursive `macro` application doesn't have to be tail-recursive.

| (robin (0 . 1) (small (0 . 1))
|   (bind make-env
|     (macro (self args env)
|       (if (equal? args ())
|         ()
|         (pair (pair (head args) (eval env (head args)))
|           (eval env
|             (pair self (tail args))))))
|     (bind b 1 (bind d 4 (make-env b d macro)))))
= ((b . 1) (d . 4) (macro . (builtin macro)))

`macro` expects exactly two arguments.

| (robin (0 . 1) (core (0 . 1))
|   ((macro (self args env)) (why hello there)))
? robin: uncaught exception: (illegal-arguments (self args env))

| (robin (0 . 1) (core (0 . 1))
|   ((macro (self args env) pair pair) (why hello there)))
? robin: uncaught exception: (illegal-arguments (self args env) pair pair)

`macro` expects its first argument to be a list of exactly three
symbols.

| (robin (0 . 1) (core (0 . 1))
|   ((macro 100 pair) (why hello there)))
? robin: uncaught exception: (illegal-arguments 100 pair)

| (robin (0 . 1) (core (0 . 1))
|   ((macro (self args) pair) (why hello there)))
? robin: uncaught exception: (illegal-arguments (self args) pair)

| (robin (0 . 1) (core (0 . 1))
|   ((macro (self args env foo) pair) (why hello there)))
? robin: uncaught exception: (illegal-arguments (self args env foo) pair)

| (robin (0 . 1) (core (0 . 1))
|   ((macro (self args 99) pair) (why hello there)))
? robin: uncaught exception: (illegal-arguments (self args 99) pair)

### `raise` ###

`raise` evaluates its argument to obtain a value, then raises an
exception with that value.

If the implementation of Robin does not support catching exceptions, or if
it does but no exception handlers have been installed in the execution
history, the Robin program will terminate with an error, ceasing execution
of all Robin processes immediately, returning control to the operating
system.  For the sake of usability, the error should include a message which
refers to the exception that triggered it, but this is not a strict
requirement.

| (robin (0 . 1) (small (0 . 1) exception (0 . 1))
|   (raise (literal (nasty-value . 999999))))
? robin: uncaught exception: (nasty-value . 999999)
