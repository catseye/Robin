;'<<SPEC'

    -> Tests for functionality "Evaluate Robin Expression (with Small)"

You can define functions with `fun`.  They can be anonymous.

    |   ((fun (a) a) (literal whee))
    = whee

Function have "closure" behavior; that is, bindings in force when a
function is defined will still be in force when the function is applied,
even if they are no longer lexically in scope.

    |   ((let
    |      ((a (literal (hi)))
    |       (f (fun (x) (list x a))))
    |     f) (literal oh))
    = (oh (hi))

Functions can take functions.

    |   (let
    |     ((apply (fun (x) (x (literal a)))))
    |     (apply (fun (r) (list r))))
    = (a)

Functions can return functions.

    |   (let
    |     ((mk (fun (x) (fun (y) (prepend y x))))
    |      (mk2 (mk (literal (vindaloo)))))
    |     (mk2 (literal chicken)))
    = (chicken vindaloo)

Arguments to functions shadow any other bindings in effect.

    |   (let
    |     ((a (literal a))
    |      (b (fun (a) (list a a))))
    |     (b 7))
    = (7 7)

A function may have no arguments at all.

    |   ((fun () 7))
    = 7

But, a function must have exactly both a body and a list of formal arguments.
Otherwise, an exception will be raised.

    |   ((fun ()))
    ? uncaught exception

    |   ((fun))
    ? uncaught exception

    |   ((fun (a) a a))
    ? uncaught exception

@An `illegal-arguments` exception will be raised if not enough arguments are
@supplied to a function call.
@
@    |   ((fun (a b) (list b a))
@    |     (prepend 1 ()))
@    ? uncaught exception: (illegal-arguments
@
@An `illegal-arguments` exception will be raised if too many arguments are
@supplied to a function call.
@
@    |   ((fun (a b) (list b a))
@    |     1 (prepend 2 ()) 3)
@    ? uncaught exception: (illegal-arguments

`fun` is basically equivalent to Scheme's `lambda`.

'<<SPEC'

(define-if-absent fun (macro (self args env)
  (bind extend-with-args (macro (self args env)
    (bind-args (env-to-extend formals actuals env-for-actuals) args env
      (if (equal? formals ())
        (if (equal? actuals ())
          env-to-extend
          (raise (list (literal illegal-arguments) (head (tail (tail args))))))
        (if (equal? actuals ())
          (raise (list (literal illegal-arguments) (head (tail (tail args)))))
          (let (
              (formal (head formals))
              (actual (head actuals))
              (rest-formals (tail formals))
              (rest-actuals (tail actuals))
              (evaled-actual (eval env-for-actuals actual))
              (binding (list formal evaled-actual))
              (extended-env (prepend binding env-to-extend))
            )
            (self extended-env rest-formals rest-actuals env-for-actuals))))))
  (macro (iself iargs ienv)
    (eval (extend-with-args env (head args) iargs ienv) (head (tail args)))))))
