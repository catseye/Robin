;'<<SPEC'

    -> Tests for functionality "Evaluate Robin Expression (with Small)"

`bind` binds a single identifier to the result of evaluating a single
expression, and makes that binding available in another expression which
it evaluates.

    |   (bind x (literal hello)
    |     (list x x))
    = (hello hello)

    |   (bind dup (macro (self args env)
    |               (list (head args) (head args)))
    |     (dup g))
    = (g g)

    |   (bind dup (macro (self args env)
    |               (bind x (eval env (head args))
    |                 (list x x)))
    |     (dup (literal g)))
    = (g g)

    |   (bind dup (macro (self args env)
    |               (bind x (eval env (head args))
    |                 (list x x)))
    |     (dup (dup (literal g))))
    = ((g g) (g g))

    |   (bind find (macro (self args env)
    |                (bind-args (alist key) args env
    |                  (if (equal? alist (literal ())) (literal ())
    |                    (if (equal? key (head (head alist)))
    |                       (head alist)
    |                       (self (tail alist) key)))))
    |     (find (literal ((c d) (e f) (a b))) (literal a)))
    = (a b)

`bind` expects exactly three arguments, or else an abort value will be produced.

    |   (bind smoosh (fun (x y) (list y x)))
    ? abort

    |   (bind smoosh)
    ? abort

    |   (bind)
    ? abort

`bind` is basically equivalent to Scheme's `let`, but only one
binding may be given.

'<<SPEC'

(define bind (macro (self args env)
  (eval
    (prepend
      (prepend (head args) (prepend (eval env (head (tail args)))
                                       ())) env)
    (head (tail (tail args))))))
