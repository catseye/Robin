(define macro (@macro (self args macro-env)
  (choose
    ((@equal? args ())
      (@raise (list (literal illegal-arguments) args)))
    ((@equal? (@tail args) ())
      (@raise (list (literal illegal-arguments) args)))
    ((@equal? (@tail (@tail args)) ())
      (bind param-list (@head args)
        (choose
          ((@equal? #f (list? param-list))
            (@raise (list (literal illegal-arguments) args)))
          ((@equal? param-list ())
            (@raise (list (literal illegal-arguments) args)))
          ((@equal? (@tail param-list) ())
            (@raise (list (literal illegal-arguments) args)))
          ((@equal? (@tail (@tail param-list)) ())
            (@raise (list (literal illegal-arguments) args)))
          ((@equal? (@tail (@tail (@tail param-list))) ())
            (@if (symbol? (@head param-list))
              (@if (symbol? (@head (@tail param-list)))
                (@if (symbol? (@head (@tail (@tail param-list))))
                  (@eval macro-env
                    (list (literal @macro) (@head args) (@head (@tail args))))
                  (@raise (list (literal illegal-arguments) args)))
                (@raise (list (literal illegal-arguments) args)))
              (@raise (list (literal illegal-arguments) args))))
          (else
            (@raise (list (literal illegal-arguments) args))))))
    (else
      (@raise (list (literal illegal-arguments) args))))))

;'XXX'

    -> Tests for functionality "Interpret Robin Program (with Small)"

`macro` is a wrapper for the `@macro` intrinsic, for which it provides
predictable failure modes.  In non-failure modes, `macro` should have
semantics identical to `@macro`.

Macros have "closure" behavior; that is, bindings in force when a
macro is defined will still be in force when the macro is applied,
even if they are no longer lexically in scope.  (Please try to ignore
the heavy `define`s that are used in this test...)

    | (display
    |   ((let
    |      ((a (literal these-are))
    |       (m (macro (self args env) (@prepend a args))))
    |     m) my args))
    = (these-are my args)

Macros can return macros.

    | (display
    |   (let
    |     ((mk (macro (self argsa env)
    |         (macro (self argsb env)
    |           (@prepend (@head argsb) argsa))))
    |      (mk2 (mk vindaloo)))
    |     (mk2 chicken)))
    = (chicken vindaloo)

Arguments to macros shadow any other bindings in effect.

    | (display
    |   (let
    |     ((args (literal a))
    |      (b (macro (self args env) (@prepend args args))))
    |     (b 7)))
    = ((7) 7)

`self` is there to let you write recursive macros.  The following
example demonstrates this; it evaluates `(prepend b d)` in an environment
where all the identifiers you list after `qqq` have been bound to 0.

    | (display
    |   (bind qqq
    |     (macro (self args env)
    |       (@if (@equal? args ())
    |         (@eval env (literal (@prepend b (@prepend d ()))))
    |         (@eval (@prepend (@prepend (@head args) (@prepend 0 ())) env)
    |           (@prepend self (@tail args)))))
    |     (bind b 1 (bind d 4 (qqq b c d)))))
    = (0 0)

    | (display
    |   (bind qqq
    |     (macro (self args env)
    |       (@if (@equal? args ())
    |         (@eval env (literal (@prepend b (@prepend d ()))))
    |         (@eval (@prepend (@prepend (@head args) (@prepend 0 ())) env)
    |           (@prepend self (@tail args)))))
    |     (bind b 1 (bind d 4 (qqq x y z)))))
    = (1 4)

Your recursive `macro` application doesn't have to be tail-recursive.

    | (display
    |   (bind make-env
    |     (macro (self args env)
    |       (@if (@equal? args ())
    |         ()
    |         (@prepend (@prepend (@head args)
    |                     (@prepend (@eval env (@head args)) ()))
    |           (@eval env
    |             (@prepend self (@tail args))))))
    |     (bind b 1 (bind d 4 (make-env b d @tail)))))
    = ((b 1) (d 4) (@tail @tail))

`macro` expects exactly two arguments.

    | (display
    |   ((macro (self args env)) (why hello there)))
    ? uncaught exception: (illegal-arguments ((self args env)))

    | (display
    |   ((macro (self args env) prepend prepend) (why hello there)))
    ? uncaught exception: (illegal-arguments ((self args env) prepend prepend))

`macro` expects its first argument to be a list of exactly three
symbols.

    | (display
    |   ((macro 100 prepend) (why hello there)))
    ? uncaught exception: (illegal-arguments (100 prepend))

    | (display
    |   ((macro (self args) prepend) (why hello there)))
    ? uncaught exception: (illegal-arguments ((self args) prepend))

    | (display
    |   ((macro (self args env foo) prepend) (why hello there)))
    ? uncaught exception: (illegal-arguments ((self args env foo) prepend))

    | (display
    |   ((macro (self args 99) prepend) (why hello there)))
    ? uncaught exception: (illegal-arguments ((self args 99) prepend))

'XXX'