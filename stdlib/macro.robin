;'<<SPEC'

### `macro` ###

    -> Tests for functionality "Evaluate Robin Expression (with literal and bind)"

`macro` takes its first argument to be a list of three formal
parameters, and its second argument to be an arbitrary expression,
and uses these two arguments to build, and evaluate to, a macro
value.

When this macro value is evaluated, the first formal argument will
be bound to the literal, unevaluated list of arguments passed to the
macro, and the second will be bound to an alist representing the
environment in effect at the point the macro value is evaluated.

These formals are conventionally called `args` and `env`,
but different names can be chosen in the `macro` definition, for
instance to avoid shadowing.

`literal`, in fact, can be defined as a macro, and it is one of the
simplest possible macros that can be written:

    | ((macro (args env) (head args)) (why hello there))
    = (why hello there)

Another facility that can be defined simply by a macro is `env`:

    (define env (macro (a e) e))

Macros have "closure" behavior; that is, bindings in force when a
macro is defined will still be in force when the macro is applied,
even if they are no longer lexically in scope.

    | ((bind a (literal these-are)
    |    (macro (args env) (prepend a args)))
    |      my args)
    = (these-are my args)

Macros can return macros.

    | (bind mk (macro (argsa env)
    |   (macro (argsb env)
    |     (prepend (head argsb) argsa)))
    |   (bind mk2 (mk vindaloo)
    |     (mk2 chicken)))
    = (chicken vindaloo)

Arguments to macros shadow any other bindings in effect.

    | (bind args (literal a)
    |   (bind b (macro (args env) (prepend args args))
    |     (b 7)))
    = ((7) 7)

Recursive macros can be written; they can be used by passing the macro to itself
when it is called.  The following examples demonstrate this.

    | (bind elem?-r
    |   (macro (args env)
    |     (bind self (eval env (head args))
    |       (bind target (eval env (head (tail args)))
    |         (bind items (eval env (head (tail (tail args))))
    |           (if (equal? items ()) #f
    |             (if (equal? (head items) target) #t
    |               (self self target (tail items))))))))
    |   (elem?-r elem?-r (literal c) (literal (a b c d e f))))
    = #t

    | (bind elem?-r
    |   (macro (args env)
    |     (bind self (eval env (head args))
    |       (bind target (eval env (head (tail args)))
    |         (bind items (eval env (head (tail (tail args))))
    |           (if (equal? items ()) #f
    |             (if (equal? (head items) target) #t
    |               (self self target (tail items))))))))
    |   (elem?-r elem?-r (literal c) (literal (a b d e f))))
    = #f

A recursive `macro` application doesn't have to be tail-recursive.

TODO write something like fibonacci as a macro here to demonstrate that.

`macro` expects exactly two arguments.

    |   ((macro (args env)) (why hello there))
    ? abort (illegal-arguments ((args env)))

    |   ((macro (args env) prepend prepend) (why hello there))
    ? abort (illegal-arguments ((args env) prepend prepend))

`macro` expects its first argument to be a list of exactly two
symbols.

    |   ((macro 100 prepend) (why hello there))
    ? abort (illegal-arguments (100 prepend))

    |   ((macro (args) prepend) (why hello there))
    ? abort (illegal-arguments ((args) prepend))

    |   ((macro (args env foo) prepend) (why hello there))
    ? abort (illegal-arguments ((args env foo) prepend))

'<<SPEC'

(require macro)
