;'<<SPEC'

### `macro` ###

    -> Tests for functionality "Evaluate Robin Expression (with Small)"

`macro` takes its first argument to be a list of three formal
parameters, and its second argument to be an arbitrary expression,
and uses these two arguments to build, and evaluate to, a macro
value.

When this macro value is evaluated, the first formal argument will
be bound to the macro itself, the second will be bound to the
literal, unevaluated list of arguments passed to the macro, and the
third will be bound to an alist representing the environment in
effect at the point the macro value is evaluated.

These formals are conventionally called `self`, `args`, and `env`,
but different names can be chosen in the `macro` definition, for
instance to avoid shadowing.

`literal`, in fact, can be defined as a macro, and it is one of the
simplest possible macros that can be written:

    | ((macro (self args env) (head args)) (why hello there))
    = (why hello there)

Another facility that can be defined simply by a macro is `env`:

    (define env (macro (s a e) e))

These tests are written against the "small" library, which defines
both of these symbols (and a few others such as `bind` and `let`).

Macros have "closure" behavior; that is, bindings in force when a
macro is defined will still be in force when the macro is applied,
even if they are no longer lexically in scope.  (Please try to ignore
the heavy `define`s that are used in this test...)

    | ((let
    |    ((a (literal these-are))
    |     (m (macro (self args env) (prepend a args))))
    |   m) my args)
    = (these-are my args)

Macros can return macros.

    | (let
    |   ((mk (macro (self argsa env)
    |       (macro (self argsb env)
    |         (prepend (head argsb) argsa))))
    |    (mk2 (mk vindaloo)))
    |   (mk2 chicken))
    = (chicken vindaloo)

Arguments to macros shadow any other bindings in effect.

    | (let
    |   ((args (literal a))
    |    (b (macro (self args env) (prepend args args))))
    |   (b 7))
    = ((7) 7)

`self` is there to let you write recursive macros.  The following
example demonstrates this; it evaluates `(prepend b d)` in an environment
where all the identifiers you list after `qqq` have been bound to 0.

    | (bind qqq
    |   (macro (self args env)
    |     (if (equal? args ())
    |       (eval env (literal (prepend b (prepend d ()))))
    |       (eval (prepend (prepend (head args) (prepend 0 ())) env)
    |         (prepend self (tail args)))))
    |   (bind b 1 (bind d 4 (qqq b c d))))
    = (0 0)

    | (bind qqq
    |   (macro (self args env)
    |     (if (equal? args ())
    |       (eval env (literal (prepend b (prepend d ()))))
    |       (eval (prepend (prepend (head args) (prepend 0 ())) env)
    |         (prepend self (tail args)))))
    |   (bind b 1 (bind d 4 (qqq x y z))))
    = (1 4)

A recursive `macro` application doesn't have to be tail-recursive.

    | (bind make-env
    |   (macro (self args env)
    |     (if (equal? args ())
    |       ()
    |       (prepend (prepend (head args)
    |                   (prepend (eval env (head args)) ()))
    |         (eval env
    |           (prepend self (tail args))))))
    |   (bind b 1 (bind d 4 (make-env b d macro))))
    = ((b 1) (d 4) (macro macro))

`macro` expects exactly two arguments.

    |   ((macro (self args env)) (why hello there))
    ? abort (illegal-arguments ((self args env)))

    |   ((macro (self args env) prepend prepend) (why hello there))
    ? abort (illegal-arguments ((self args env) prepend prepend))

`macro` expects its first argument to be a list of exactly three
symbols.

    |   ((macro 100 prepend) (why hello there))
    ? abort (illegal-arguments (100 prepend))

    |   ((macro (self args) prepend) (why hello there))
    ? abort (illegal-arguments ((self args) prepend))

    |   ((macro (self args env foo) prepend) (why hello there))
    ? abort (illegal-arguments ((self args env foo) prepend))

    |   ((macro (self args 99) prepend) (why hello there))
    ? abort (illegal-arguments ((self args 99) prepend))

'<<SPEC'

(require macro)
