;'<<SPEC'

### `catch` ###

    -> Tests for functionality "Evaluate Robin Expression (with literal and list)"

`catch` installs an exception handler.

If an exception is raised when evaluating the final argument of
`catch`, the exception value is bound to the symbol given as the
first argument of `catch`, and the second argument of `catch` is
evaluated in that new environment.

    | (catch error (list error #f)
    |   (raise (literal (nasty-value 999999))))
    = ((nasty-value 999999) #f)

If an exception is raised in the body of a macro that is applied
in the context of a `catch`, it will still be catched.

    | (catch error (list error #f)
    |   ((macro (self args env) (raise (literal (nasty-value 1111)))) joe))
    = ((nasty-value 1111) #f)

If nothing is raised, `catch` will evaluate to whatever its body
evaluated to.

    | (catch error (list error #f) 42)
    = 42

The innermost `catch` will catch the exception.

    | (catch error (list error 5)
    |   (catch error (list error 9)
    |     (raise (literal derpy-value))))
    = (derpy-value 9)

An exception raised from within an exception handler is
caught by the next innermost exception handler.

    | (catch error (list error 5)
    |   (catch error (list error 9)
    |     (catch error (raise (list error error))
    |       (raise 7))))
    = ((7 7) 9)

`catch` expects its first argument to be a symbol.

    | (catch (3 4) (list error #f) 42)
    ? uncaught exception: (illegal-arguments ((3 4) (list error #f) 42))

`catch` expects exactly three arguments.

    | (catch error (list error #f))
    ? uncaught exception: (illegal-arguments (error (list error #f)))

    | (catch error (list error #f) 42 43)
    ? uncaught exception: (illegal-arguments (error (list error #f) 42 43))

    -> Tests for functionality "Evaluate Robin Expression (with Small)"

Note that the exception handler is evaluated in the environment it is
*defined* in, not the environment in effect when the exception is *handled*.

    | (catch error (list flop error)
    |   (bind flop 1
    |     (raise 2)))
    ? uncaught exception: (unbound-identifier flop)

The exception handler that is invoked when an exception occurs is the
exception handler that was in effect at the time of definition, not
at the time of calling.  That is, exception handlers have lexical
scope, not dynamic scope.  This is different from most other programming
languages.  This might be essentially the same thing as what's sometimes
called an "ejector".

In the following, the `raise` isn't caught by the `catch` because the
`catch` wasn't in effect when the `raise` was defined, i.e. the `catch`
does not lexically enclose the `raise`.

    | (bind flop (fun (x) (raise x))
    |   (list
    |     (catch error (list 55 error) (flop 44))
    |     (catch error (list 66 error) (flop 44))))
    ? uncaught exception: 44

'<<SPEC'

(require catch)
