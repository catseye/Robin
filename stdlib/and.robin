;'<<SPEC'

    -> Tests for functionality "Evaluate Robin Expression (with Boolean)"

`and` evaluates both of its arguments to booleans, and evaluates to the
logical conjunction (boolean "and") of these two values.

    | (and #t #t)
    = #t

    | (and #t #f)
    = #f

    | (and #f #t)
    = #f

    | (and #f #f)
    = #f

`and` expects exactly two arguments.

    | (and #f)
    ? uncaught exception

    | (and #t #f #f)
    ? uncaught exception: (illegal-arguments (#t #f #f))

`and` expects both of its arguments to be booleans.

    | (and 100 #t)
    ? uncaught exception: (expected-boolean 100)

    | (and #t 99)
    ? uncaught exception: (expected-boolean 99)

`and` is short-circuiting in the sense that no arguments after the first
`#f` argument will be evaluated.  Fully testing this requires side-effects,
but it can be demonstrated as follows.

    | (and #f 100)
    = #f

'<<SPEC'

(define and (macro (self args env)
  (if (equal? (tail (tail args)) ())
    (if (eval env (head args))
      (if (eval env (head (tail args))) #t #f)
      #f)
    (raise (list (literal illegal-arguments) args)))))
