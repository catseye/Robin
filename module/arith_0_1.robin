(robin (0 1) ((small (0 1) *) (env (0 1) *))
  (let (
    (add (fun (a b)
      (subtract a (subtract 0 b))))
    (+ (macro (self args env)
      (if (equal? args ())
        0
        (add (eval env (head args))
             (eval env (prepend self (tail args)))))))
    (sum-r (fun (self li)
      (if (equal? li ())
        0
        (+ (head li) (self self (tail li))))))
    (sum (fun (li)
      (sum-r sum-r li)))
    (- (fun (a b)
      (subtract a b)))
    (multiply (fun (a b)
      (if (equal? b 0) 0 (divide a (divide 1 b)))))
    (* (macro (self args env)
      (if (equal? args ())
        1
        (multiply (eval env (head args))
                  (eval env (prepend self (tail args)))))))
    (product-r (fun (self li)
      (if (equal? li ())
        1
        (* (head li) (self self (tail li))))))
    (product (fun (li)
      (product-r product-r li)))
    (/ (fun (a b)
      (divide a b)))
    (abs (fun (a)
      (* a (sign a))))
    (frac (fun (a)
      (subtract (abs a) (floor (abs a)))))
    (integer? (fun (a)
      (equal? (frac a) 0)))
    (div (fun (a b)
      (floor (/ (floor a) (floor b)))))
    (rem (fun (a b)
      (- a (* (div a b) b))))
    (> (fun (a b)
      (equal? (sign (- a b)) 1)))
    (>= (fun (a b)
      (if (equal? a b) #t (equal? (sign (- a b)) 1))))
    (< (fun (a b)
      (equal? (sign (- a b)) (- 0 1))))
    (<= (fun (a b)
      (if (equal? a b) #t (equal? (sign (- a b)) (- 0 1)))))
    (cmp-list?-r (fun (self op li)
      (if (equal? li ()) #t
        (if (equal? (tail li) ()) #t
          (if (op (head li) (head (tail li)))
            (self self op (tail li))
            #f)))))
    (ascending? (fun (li)
      (cmp-list?-r cmp-list?-r <= li)))
    (strictly-ascending? (fun (li)
      (cmp-list?-r cmp-list?-r < li)))
    (natural? (fun (a)
      (if (equal? (frac a) 0) (>= a 0) #f)))
    )
    (export + sum - * product / abs frac integer?
            div rem > >= < <= natural?
            ascending? strictly-ascending?)))
