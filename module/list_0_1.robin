(robin (0 . 1) (small (0 . 1))
  (let (
    (empty? (fun (li)
      (equal? li ())))
    (list (macro (self args env)
      (if (empty? args)
        ()
        (pair (eval env (head args))
              (eval env (pair self (tail args)))))))
    (list? (fun (li)
      (bind list?-r (fun (self li)
        (if (empty? li)
          #t
          (if (pair? li)
            (self self (tail li))
            #f)))
        (list?-r list?-r li))))
    (map (fun (app li)
      (bind map-r
        (fun (self app li)
          (if (empty? li)
            ()
            (pair (app (head li)) (self self app (tail li)))))
        (map-r map-r app li))))
    (fold (fun (app acc li)
      (bind fold-r (fun (self app acc li)
        (if (empty? li)
          acc
          (self self app (app (head li) acc) (tail li))))
        (fold-r fold-r app acc li))))
    (reverse (fun (li)
      (fold pair () li)))
    (filter (fun (pred li)
      (reverse (fold
        (fun (x acc) (if (pred x) (pair x acc) acc))
        () li))))
    (first (fun (pred li)
      (bind first-r (fun (self pred li)
        (if (empty? li)
          ()
          (if (pred (head li))
            (pair (head li) ())
            (self self pred (tail li)))))
        (first-r first-r pred li))))
    (append (fun (li new-tail)
      (bind append-r (fun (self li new-tail)
        (if (empty? li)
          new-tail
          (pair (head li) (self self (tail li) new-tail))))
      (append-r append-r li new-tail))))
    )
    (list
      (pair (literal list) list)
      (pair (literal empty?) empty?)
      (pair (literal list?) list?)
      (pair (literal map) map)
      (pair (literal fold) fold)
      (pair (literal reverse) reverse)
      (pair (literal filter) filter)
      (pair (literal first) first)
      (pair (literal append) append)
    )
  )
)
