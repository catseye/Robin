(robin (0 . 1) (small (0 . 1) list (0 . 1) env (0 . 1)
                concurrency (0 . 1) crude-io (0 . 1))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with (literal pure) head))
    (tail     (with (literal pure) tail))
    (pair     (with (literal pure) pair))
    (pair?    (with (literal pure) pair?))
    (symbol?  (with (literal pure) symbol?))
    (number?  (with (literal pure) number?))
    (boolean? (with (literal pure) boolean?))
    (macro?   (with (literal pure) macro?))
    (subtract (with (literal pure) subtract))
    (divide   (with (literal pure) divide))
    (floor    (with (literal pure) floor))
    (sign     (with (literal pure) sign))
    (macro    (with (literal definer) (with (literal pure) macro)))
    (if       (with (literal pure) if))
    (with     (with (literal pure) with))
    (has?     (with (literal pure) has?))
    (literal  (with (literal pure) literal))
    (env      (with (literal pure) env))
    (fun      (with (literal definer) (with (literal pure) fun)))
    (lookup (fun (x li)
      (find
        (fun (pr) (equal? (head pr) x))
        li)))
    (pure-args?-r (fun (self pure?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((pair? li)
          (if (pure?-r pure?-r env args (head li))
            (self self pure?-r env args (tail li))
            #f))
        (else
          #f))))
    (pure?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? (literal pure) expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX The following is badly written.''
        ((pair? expr)
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env))
                (applier       (if (empty? maybe-applier) () (head maybe-applier))))
            ;(call! crude-output write
              (list apply-expr applier (has? (literal pure) applier))
              foo)
            (choose
              ((equal? applier ())
                #f)
              ((has? (literal definer) applier)
                ;''An expression which evaluates to a function (or macro)
                   is pure, but we may want to evaluate the function's (or
                   macro's) body to see if it evaluates to a pure function
                   (or macro).  This will be valuable in case the function
                   (or macro) is used later in the larger expression, i.e.
                   (bind x (fun ...) (x y z))  I guess we might do that in
                   bind itself, though.''
                #t)
              ((self self env args apply-expr)
                ;''XXX We should only do this if the applier in question
                   is a function (or function-like.)  It may be a macro
                   which does anything it wants to the args.  This would
                   be harder to analyze in the general case.''
                (pure-args?-r pure-args?-r self env args (tail expr)))
              (else
                #f))))
        ((symbol? expr)
          (bind val (lookup expr env)
            (if (equal? val ())
              #f
              (self self env args (tail (head val))))))
        (else            #f))))
    (pure? (fun (env args expr) (pure?-r pure?-r env args expr)))
    (pure? (with (literal pure) pure?))
    )
    (export head tail pair pair? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env fun
            pure?)))
