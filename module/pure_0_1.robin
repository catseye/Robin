(robin (0 1) ((small (0 1) *) (list (0 1) *) (env (0 1) *) (metadata (0 1) *))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with pure #t head))
    (tail     (with pure #t tail))
    (prepend  (with pure #t prepend))
    (list?    (with pure #t list?))
    (symbol?  (with pure #t symbol?))
    (number?  (with pure #t number?))
    (boolean? (with pure #t boolean?))
    (macro?   (with pure #t macro?))
    (subtract (with pure #t subtract))
    (divide   (with pure #t divide))
    (floor    (with pure #t floor))
    (sign     (with pure #t sign))
    (macro    (with definer #t (with pure #t macro)))
    (if       (with pure #t if))
    (with     (with pure #t with))
    (has?     (with pure #t has?))
    (literal  (with pure #t literal))
    (bind     (with binder #t (with pure #t bind)))
    (env      (with pure #t env))
    (fun      (with definer #t (with pure #t fun)))
    (dummy-fun (fun (x) x))
    (pure-fun-defn?-r (fun (self pure-expr?-r env expr)
      ;''XXX The following is badly written.''
      (choose
        ((list? expr)
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env)))
            (choose
              ((equal? maybe-applier (list fun))
                (let ((args (head (tail expr)))
                      (body (head (tail (tail expr)))))
                  (pure-expr?-r pure-expr?-r env args body)))
              (else
                #f))))
        ((symbol? expr)
          (bind maybe-val (lookup expr env)
            (choose
              ((equal? maybe-val ())
                #f)
              ((macro? (head maybe-val))
                (has? pure (head maybe-val)))
              (else
                #f))))
        (else
          #f))))
    ;''TODO: can we replace this with an `all` fold?''
    ;''TODO: instead of passing `args` here we should pre-extend
       `env` with some dummy values with appropriate metadata''
    (pure-args?-r (fun (self pure-expr?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((list? li)
          (if (pure-expr?-r pure-expr?-r env args (head li))
            (self self pure-expr?-r env args (tail li))
            #f))
        (else
          #f))))
    ;''TODO: instead of passing `args` here we should pre-extend
       `env` with some dummy values with appropriate metadata''
    (pure-expr?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? pure expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX The following is badly written.''
        ((list? expr)
          ;''If the head of the list is an S-expr which represents a
             pure fun, such as 'head' or '(fun (x) x)', then this
             expression is pure if all of the actual arguments are
             pure.  BUT -- first we must special-case some things.''
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env)))
            (choose
              ((equal? maybe-applier ())
                #f)
              ((has? binder (head maybe-applier))
                ;''When analyzing a `bind` expression, we analyze the value
                   being bound to see if it, too, is pure or not.  We then
                   extend the environment with a value for the bound
                   identifier; this value is a dummy value, but it does
                   carry the appropriate metadata, so it correctly detects
                   if the value is pure or not, if it subsequently used.''
                (let
                  ((ident       (head (tail expr)))
                   (bound-expr  (head (tail (tail expr)))))
                  ;''If the expr being bound is pure...''
                  (if (self self env args bound-expr)
                    ;''Analyze the body in a new environment
                       in which this identifier is bound to a
                       placeholder; mark the placeholder as pure
                       iff `pure-fun-defn?` is true for the
                       bound expression.''
                    (let
                      ((bound-pure-fun
                        (pure-fun-defn?-r pure-fun-defn?-r
                            self env bound-expr))
                       (placeholder
                        (if bound-pure-fun
                          (with pure #t dummy-fun)
                          dummy-fun))
                       (new-env
                         (extend ident placeholder env))
                       (body-expr
                        (head (tail (tail (tail expr))))))
                      (self self new-env args body-expr))
                    #f)))
              ((has? definer (head maybe-applier))
                ;''A "definer" expression (such as `macro` or `fun`), which
                   simply evaluates to a macro value of some kind, is pure.
                   
                   XXX We will still want to evaluate the body of the
                   definition, to see if it evaluates to a pure function
                   (or macro).  This will be valuable in case the function
                   (or macro) is used later in the larger expression, i.e.
                   (bind x (fun ...) (x y z))''
                (self self env args apply-expr))
              ((pure-fun-defn?-r pure-fun-defn?-r self env apply-expr)
                (pure-args?-r pure-args?-r self env args (tail expr)))
              ((self self env args apply-expr)
                ;''XXX We should only do this if the applier in question
                   is a function (or function-like.)  It may be a macro
                   which does anything it wants to the args.  This would
                   be harder to analyze in the general case.''
                (pure-args?-r pure-args?-r self env args (tail expr)))
              (else
                #f))))
        ((symbol? expr)
          (bind maybe-val (lookup expr env)
            (if (equal? maybe-val ())
              #f
              (self self env args (head maybe-val)))))
        (else
          #f))))
    (pure-expr? (fun (env args expr) (pure-expr?-r pure-expr?-r env args expr)))
    ;''The following is mainly for testing''
    (pure-fun-defn? (fun (env expr)
      (pure-fun-defn?-r pure-fun-defn?-r pure-expr?-r env expr)))
    )
    (export head tail prepend list? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env fun bind
            pure-expr? pure-fun-defn?)))
