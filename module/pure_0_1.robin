(robin (0 . 1) (small (0 . 1) list (0 . 1) env (0 . 1))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with (literal pure) head))
    (tail     (with (literal pure) tail))
    (pair     (with (literal pure) pair))
    (pair?    (with (literal pure) pair?))
    (symbol?  (with (literal pure) symbol?))
    (number?  (with (literal pure) number?))
    (boolean? (with (literal pure) boolean?))
    (macro?   (with (literal pure) macro?))
    (subtract (with (literal pure) subtract))
    (divide   (with (literal pure) divide))
    (floor    (with (literal pure) floor))
    (sign     (with (literal pure) sign))
    (macro    (with (literal definer) (with (literal pure) macro)))
    (if       (with (literal pure) if))
    (with     (with (literal pure) with))
    (has?     (with (literal pure) has?))
    (literal  (with (literal pure) literal))
    (bind     (with (literal binder) (with (literal pure) bind)))
    (env      (with (literal pure) env))
    (fun      (with (literal definer) (with (literal pure) fun)))
    (pure-macro-defn?-r (fun (self pure-expr?-r env args expr)
      ;''XXX to be written''
      #t))
    ;''TODO: can we replace this with an `all` fold?''
    (pure-args?-r (fun (self pure-expr?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((pair? li)
          (if (pure-expr?-r pure-expr?-r env args (head li))
            (self self pure-expr?-r env args (tail li))
            #f))
        (else
          #f))))
    (pure-expr?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? (literal pure) expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX The following is badly written.''
        ((pair? expr)
          (let ((apply-expr (head expr))
                (applier    (lookup apply-expr () env)))
            (choose
              ((equal? applier ())
                #f)
              ((has? (literal binder) applier)
                ;''When analyzing a `bind` expression, we analyze the value
                   being bound to see if it, too, is pure or not.  We then
                   extend the environment with a value for the bound
                   identifier; this value is a dummy value, but it does
                   carry the appropriate metadata, so it correctly detects
                   if the value is pure or not, if it subsequently used.''
                (let
                  ((ident       (head (tail expr)))
                   (bound-expr  (head (tail (tail expr))))
                   (body-expr   (head (tail (tail (tail expr)))))
                   ;''XXX this should be: if the expr being bound isn't pure,
                      return #f.  Otherwise, create the new environment with
                      the placeholder; mark the placeholder as pure if
                      `pure-macro-defn?` is true for the bound expr.''
                   (bound-pure  (self self env args bound-expr))
                   (placeholder (if bound-pure (with (literal pure) 888) 888))
                   (new-env     (pair (pair ident placeholder) env))
                  )
                  (self self new-env args body-expr)))
              ((has? (literal definer) applier)
                ;''A "definer" expression (such as `macro` or `fun`), which
                   simply evaluates to a macro value of some kind, is pure.
                   
                   XXX We will still want to evaluate the body of the
                   definition, to see if it evaluates to a pure function
                   (or macro).  This will be valuable in case the function
                   (or macro) is used later in the larger expression, i.e.
                   (bind x (fun ...) (x y z))  We might do that in
                   bind itself, though.''
                (self self env args apply-expr))
              ((self self env args apply-expr)
                ;''XXX We should only do this if the applier in question
                   is a function (or function-like.)  It may be a macro
                   which does anything it wants to the args.  This would
                   be harder to analyze in the general case.''
                (pure-args?-r pure-args?-r self env args (tail expr)))
              (else
                #f))))
        ((symbol? expr)
          (bind val (lookup expr () env)
            (if (equal? val ())
              #f
              (self self env args val))))
        (else            #f))))
    (pure-expr? (fun (env args expr) (pure-expr?-r pure-expr?-r env args expr)))
    )
    (export head tail pair pair? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env fun bind
            pure-expr? pure-macro-defn?)))
