(robin (0 . 1) (small (0 . 1) list (0 . 1) env (0 . 1))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with (literal pure) head))
    (tail     (with (literal pure) tail))
    (pair     (with (literal pure) pair))
    (pair?    (with (literal pure) pair?))
    (symbol?  (with (literal pure) symbol?))
    (number?  (with (literal pure) number?))
    (boolean? (with (literal pure) boolean?))
    (macro?   (with (literal pure) macro?))
    (subtract (with (literal pure) subtract))
    (divide   (with (literal pure) divide))
    (floor    (with (literal pure) floor))
    (sign     (with (literal pure) sign))
    (macro    (with (literal pure) macro))
    (if       (with (literal pure) if))
    (with     (with (literal pure) with))
    (has?     (with (literal pure) has?))
    (literal  (with (literal pure) literal))
    (env      (with (literal pure) env))
    (lookup (fun (x li)
      (find
        (fun (pr) (equal? (head pr) x))
        li)))
    (pure-args?-r (fun (self pure?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((pair? li)
          (if (pure?-r pure?-r env args (head li))
            (self self pure?-r env args (tail li))
            #f))
        (else
          #f))))
    (pure?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? (literal pure) expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX This assumes that this is an application of a functional
           value.  It should not make that assumption.  It could be a
           macro which does whatever with its arguments.  That makes the
           general case hard.  For now, we might need to be satisfied with
           special-casing `macro` and `fun` here.''
        ((pair? expr)
          ;''XXX do more special-casing here''
          (if (self self env args (head expr))
            (pure-args?-r pure-args?-r self env args (tail expr))
            #f))
        ((symbol? expr)
          (bind val (lookup expr env)
            (if (equal? val ())
              #f
              (self self env args (tail (head val))))))
        (else            #f))))
    (pure? (fun (env args expr) (pure?-r pure?-r env args expr)))
    )
    (export head tail pair pair? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env
            pure?)))
