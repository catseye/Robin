(robin (0 . 1) (small (0 . 1) list (0 . 1) env (0 . 1))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with (literal pure) head))
    (tail     (with (literal pure) tail))
    (pair     (with (literal pure) pair))
    (pair?    (with (literal pure) pair?))
    (symbol?  (with (literal pure) symbol?))
    (number?  (with (literal pure) number?))
    (boolean? (with (literal pure) boolean?))
    (macro?   (with (literal pure) macro?))
    (subtract (with (literal pure) subtract))
    (divide   (with (literal pure) divide))
    (floor    (with (literal pure) floor))
    (sign     (with (literal pure) sign))
    (macro    (with (literal definer) (with (literal pure) macro)))
    (if       (with (literal pure) if))
    (with     (with (literal pure) with))
    (has?     (with (literal pure) has?))
    (literal  (with (literal pure) literal))
    (bind     (with (literal binder) (with (literal pure) bind)))
    (env      (with (literal pure) env))
    (fun      (with (literal definer) (with (literal pure) fun)))
    (pure-macro-defn?-r (fun (self pure-expr?-r env expr)
      ;''XXX The following is badly written.''
      (choose
        ((macro? expr)
          (has? (literal pure) expr))
        ((pair? expr)
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env)))
            (choose
              ((equal? maybe-applier (list fun))
                (let ((args (head (tail expr)))
                      (body (head (tail (tail expr)))))
                  (pure-expr?-r pure-expr?-r env args body)))
              (else
                #f))))
        ((symbol? expr)
          (bind maybe-val (lookup expr env)
            (if (equal? maybe-val ())
              #f
              (self self pure-expr?-r env (head maybe-val)))))
        (else
          #f))))
    ;''TODO: can we replace this with an `all` fold?''
    ;''TODO: instead of passing `args` here we should pre-extend
       `env` with some dummy values with appropriate metadata''
    (pure-args?-r (fun (self pure-expr?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((pair? li)
          (if (pure-expr?-r pure-expr?-r env args (head li))
            (self self pure-expr?-r env args (tail li))
            #f))
        (else
          #f))))
    ;''TODO: instead of passing `args` here we should pre-extend
       `env` with some dummy values with appropriate metadata''
    (pure-expr?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? (literal pure) expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX The following is badly written.''
        ((pair? expr)
          (let ((apply-expr    (head expr))
                ;''XXX we really shouldn't be lookup'ing here''
                (maybe-applier (lookup apply-expr env)))
            (choose
              ((pure-macro-defn?-r pure-macro-defn?-r self env apply-expr)
                #t)
              ((equal? maybe-applier ())
                #f)
              ((has? (literal binder) (head maybe-applier))
                ;''When analyzing a `bind` expression, we analyze the value
                   being bound to see if it, too, is pure or not.  We then
                   extend the environment with a value for the bound
                   identifier; this value is a dummy value, but it does
                   carry the appropriate metadata, so it correctly detects
                   if the value is pure or not, if it subsequently used.''
                (let
                  ((ident       (head (tail expr)))
                   (bound-expr  (head (tail (tail expr))))
                   (body-expr   (head (tail (tail (tail expr)))))
                   ;''XXX this should be: if the expr being bound isn't pure,
                      return #f.  Otherwise, create the new environment with
                      the placeholder; mark the placeholder as pure if
                      `pure-macro-defn?` is true for the bound expr.''
                   (bound-pure  (self self env args bound-expr))
                   (placeholder (if bound-pure (with (literal pure) 888) 888))
                   (new-env     (pair (pair ident placeholder) env))
                  )
                  (self self new-env args body-expr)))
              ((has? (literal definer) (head maybe-applier))
                ;''A "definer" expression (such as `macro` or `fun`), which
                   simply evaluates to a macro value of some kind, is pure.
                   
                   XXX We will still want to evaluate the body of the
                   definition, to see if it evaluates to a pure function
                   (or macro).  This will be valuable in case the function
                   (or macro) is used later in the larger expression, i.e.
                   (bind x (fun ...) (x y z))''
                (self self env args apply-expr))
              ((self self env args apply-expr)
                ;''XXX We should only do this if the applier in question
                   is a function (or function-like.)  It may be a macro
                   which does anything it wants to the args.  This would
                   be harder to analyze in the general case.''
                (pure-args?-r pure-args?-r self env args (tail expr)))
              (else
                #f))))
        ((symbol? expr)
          (bind maybe-val (lookup expr env)
            (if (equal? maybe-val ())
              #f
              (self self env args (head maybe-val)))))
        (else
          #f))))
    (pure-expr? (fun (env args expr) (pure-expr?-r pure-expr?-r env args expr)))
    ;''The following is mainly for testing''
    (pure-macro-defn? (fun (env expr)
      (pure-macro-defn?-r pure-macro-defn?-r pure-expr?-r env expr)))
    )
    (export head tail pair pair? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env fun bind
            pure-expr? pure-macro-defn?)))
