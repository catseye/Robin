(robin (0 . 1) (small (0 . 1) list (0 . 1) env (0 . 1))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with (literal pure) head))
    (tail     (with (literal pure) tail))
    (pair     (with (literal pure) pair))
    (pair?    (with (literal pure) pair?))
    (symbol?  (with (literal pure) symbol?))
    (number?  (with (literal pure) number?))
    (boolean? (with (literal pure) boolean?))
    (macro?   (with (literal pure) macro?))
    (subtract (with (literal pure) subtract))
    (divide   (with (literal pure) divide))
    (floor    (with (literal pure) floor))
    (sign     (with (literal pure) sign))
    (macro    (with (literal pure) macro))
    (if       (with (literal pure) if))
    (with     (with (literal pure) with))
    (has?     (with (literal pure) has?))
    (literal  (with (literal pure) literal))
    (env      (with (literal pure) env))
    (lookup (fun (x li)
      (find
        (fun (pr) (equal? (head pr) x))
        li)))
    (pure-args?-r (fun (self pure?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((pair? li)
          (if (pure?-r pure?-r env args (head li))
            (self self pure?-r env args (tail li))
            #f))
        (else
          #f))))
    (pure?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? (literal pure) expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX This assumes that this is an application of a functional
           value.  It should not make that assumption.  It could be a
           macro which does whatever with its arguments.  That makes the
           general case hard.  For now, we might need to be satisfied with
           special-casing `macro` and `fun` here.
           
           XXX This is badly written.''
        ((pair? expr)
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env))
                (applier       (if (empty? maybe-applier) () (head maybe-applier))))
            (choose
              ((equal? applier ())
                #f)
              ((equal? apply-expr (literal macro)) ;XXX
                ;''An expression which evaluates to a macro is pure,
                   but see note on functions directly below.''
                #t)
              ((equal? apply-expr (literal fun)) ;XXX
                ;''An expression which evaluates to a function is pure,
                   but we may want to evaluate the function's body to see
                   if it evaluates to a pure function.  This would be
                   valuable in case the function is used later in the
                   larger expression, i.e. (bind x (fun ...) (x y z))''
                #t)
              ((self self env args apply-expr)
                (pure-args?-r pure-args?-r self env args (tail expr)))
              (else
                #f))))
        ((symbol? expr)
          (bind val (lookup expr env)
            (if (equal? val ())
              #f
              (self self env args (tail (head val))))))
        (else            #f))))
    (pure? (fun (env args expr) (pure?-r pure?-r env args expr)))
    )
    (export head tail pair pair? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env
            pure?)))
