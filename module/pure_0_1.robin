(robin (0 1) ((small (0 1) *) (list (0 1) *) (env (0 1) *))
  ;''This is an EXPERIMENTAL module for EXPERIMENTING with
     static analysis in Robin using metadata on values.''
  (let (
    (head     (with (literal pure) head))
    (tail     (with (literal pure) tail))
    (prepend  (with (literal pure) prepend))
    (list?    (with (literal pure) list?))
    (symbol?  (with (literal pure) symbol?))
    (number?  (with (literal pure) number?))
    (boolean? (with (literal pure) boolean?))
    (macro?   (with (literal pure) macro?))
    (subtract (with (literal pure) subtract))
    (divide   (with (literal pure) divide))
    (floor    (with (literal pure) floor))
    (sign     (with (literal pure) sign))
    (macro    (with (literal definer) (with (literal pure) macro)))
    (if       (with (literal pure) if))
    (with     (with (literal pure) with))
    (has?     (with (literal pure) has?))
    (literal  (with (literal pure) literal))
    (bind     (with (literal binder) (with (literal pure) bind)))
    (env      (with (literal pure) env))
    (fun      (with (literal definer) (with (literal pure) fun)))
    (dummy-fun (fun (x) x))
    (pure-fun-defn?-r (fun (self pure-expr?-r env expr)
      ;''XXX The following is badly written.''
      (choose
        ((list? expr)
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env)))
            (choose
              ((equal? maybe-applier (list fun))
                (let ((args (head (tail expr)))
                      (body (head (tail (tail expr)))))
                  (pure-expr?-r pure-expr?-r env args body)))
              (else
                #f))))
        ((symbol? expr)
          (bind maybe-val (lookup expr env)
            (choose
              ((equal? maybe-val ())
                #f)
              ((macro? (head maybe-val))
                (has? (literal pure) (head maybe-val)))
              (else
                #f))))
        (else
          #f))))
    ;''TODO: can we replace this with an `all` fold?''
    ;''TODO: instead of passing `args` here we should pre-extend
       `env` with some dummy values with appropriate metadata''
    (pure-args?-r (fun (self pure-expr?-r env args li)
      (choose
        ((empty? li)
          #t)
        ((list? li)
          (if (pure-expr?-r pure-expr?-r env args (head li))
            (self self pure-expr?-r env args (tail li))
            #f))
        (else
          #f))))
    ;''TODO: instead of passing `args` here we should pre-extend
       `env` with some dummy values with appropriate metadata''
    (pure-expr?-r (fun (self env args expr)
      (choose
        ((elem? expr args) #t)
        ((number? expr)    #t)
        ((macro? expr)     (has? (literal pure) expr))
        ((boolean? expr)   #t)
        ((empty? expr)     #t)
        ;''XXX The following is badly written.''
        ((list? expr)
          ;''If the head of the list is an S-expr which represents a
             pure fun, such as 'head' or '(fun (x) x)', then this
             expression is pure if all of the actual arguments are
             pure.  BUT -- first we must special-case some things.''
          (let ((apply-expr    (head expr))
                (maybe-applier (lookup apply-expr env)))
            (choose
              ((equal? maybe-applier ())
                #f)
              ((has? (literal binder) (head maybe-applier))
                ;''When analyzing a `bind` expression, we analyze the value
                   being bound to see if it, too, is pure or not.  We then
                   extend the environment with a value for the bound
                   identifier; this value is a dummy value, but it does
                   carry the appropriate metadata, so it correctly detects
                   if the value is pure or not, if it subsequently used.''
                (let
                  ((ident       (head (tail expr)))
                   (bound-expr  (head (tail (tail expr)))))
                  ;''If the expr being bound is pure...''
                  (if (self self env args bound-expr)
                    ;''Analyze the body in a new environment
                       in which this identifier is bound to a
                       placeholder; mark the placeholder as pure
                       iff `pure-fun-defn?` is true for the
                       bound expression.''
                    (let
                      ((bound-pure-fun
                        (pure-fun-defn?-r pure-fun-defn?-r
                            self env bound-expr))
                       (placeholder
                        (if bound-pure-fun
                          (with (literal pure) dummy-fun)
                          dummy-fun))
                       (new-env
                         (extend ident placeholder env))
                       (body-expr
                        (head (tail (tail (tail expr))))))
                      (self self new-env args body-expr))
                    #f)))
              ((has? (literal definer) (head maybe-applier))
                ;''A "definer" expression (such as `macro` or `fun`), which
                   simply evaluates to a macro value of some kind, is pure.
                   
                   XXX We will still want to evaluate the body of the
                   definition, to see if it evaluates to a pure function
                   (or macro).  This will be valuable in case the function
                   (or macro) is used later in the larger expression, i.e.
                   (bind x (fun ...) (x y z))''
                (self self env args apply-expr))
              ((pure-fun-defn?-r pure-fun-defn?-r self env apply-expr)
                (pure-args?-r pure-args?-r self env args (tail expr)))
              ((self self env args apply-expr)
                ;''XXX We should only do this if the applier in question
                   is a function (or function-like.)  It may be a macro
                   which does anything it wants to the args.  This would
                   be harder to analyze in the general case.''
                (pure-args?-r pure-args?-r self env args (tail expr)))
              (else
                #f))))
        ((symbol? expr)
          (bind maybe-val (lookup expr env)
            (if (equal? maybe-val ())
              #f
              (self self env args (head maybe-val)))))
        (else
          #f))))
    (pure-expr? (fun (env args expr) (pure-expr?-r pure-expr?-r env args expr)))
    ;''The following is mainly for testing''
    (pure-fun-defn? (fun (env expr)
      (pure-fun-defn?-r pure-fun-defn?-r pure-expr?-r env expr)))
    )
    (export head tail prepend list? symbol? number? macro? boolean?
            subtract divide floor sign macro if with has?
            eval
            literal env fun bind
            pure-expr? pure-fun-defn?)))
