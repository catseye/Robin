(robin (0 1) ((small (0 1) *) (env (0 1) *) (list (0 1) *))
  (let (
    (and (macro (self args env)
      (if (equal? (length args) 2)
        (if (eval env (head args))
          (if (eval env (head (tail args))) #t #f)
          #f)
        (raise (list (literal illegal-arguments) args)))))
    (and* (macro (self args env)
      (if (equal? args ())
        #t
        (and (eval env (head args))
             (eval env (prepend self (tail args)))))))
    (conj-r (fun (self li)
      (if (equal? li ())
        #t
        (and (head li)
             (self self (tail li))))))
    (conj (fun (li)
      (conj-r conj-r li)))
    (or (macro (self args env)
      (if (equal? (length args) 2)
        (if (eval env (head args))
          #t
          (if (eval env (head (tail args))) #t #f))
        (raise (list (literal illegal-arguments) args)))))
    (or* (macro (self args env)
      (if (equal? args ())
        #f
        (or (eval env (head args))
            (eval env (prepend self (tail args)))))))
    (disj-r (fun (self li)
      (if (equal? li ())
        #f
        (or (head li)
            (self self (tail li))))))
    (disj (fun (li)
      (disj-r disj-r li)))
    (not (fun (a)
      (if a #f #t)))
    (xor (fun (a b)
      (or (and a (not b)) (and (not a) b))))
    )
    (export and and* conj or or* disj not xor)))
